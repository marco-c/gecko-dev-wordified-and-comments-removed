#
ifndef
__ARCHIVE_WIM_IN_H
#
define
__ARCHIVE_WIM_IN_H
#
include
"
.
.
/
.
.
/
.
.
/
.
.
/
C
/
Alloc
.
h
"
#
include
"
.
.
/
.
.
/
.
.
/
Common
/
MyBuffer
.
h
"
#
include
"
.
.
/
.
.
/
.
.
/
Common
/
MyXml
.
h
"
#
include
"
.
.
/
.
.
/
.
.
/
Windows
/
PropVariant
.
h
"
#
include
"
.
.
/
.
.
/
Compress
/
CopyCoder
.
h
"
#
include
"
.
.
/
.
.
/
Compress
/
LzmsDecoder
.
h
"
#
include
"
.
.
/
.
.
/
Compress
/
LzxDecoder
.
h
"
#
include
"
.
.
/
IArchive
.
h
"
namespace
NArchive
{
namespace
NWim
{
const
unsigned
kDirRecordSizeOld
=
62
;
const
unsigned
kDirRecordSize
=
102
;
namespace
NResourceFlags
{
const
Byte
kMetadata
=
1
<
<
1
;
const
Byte
kCompressed
=
1
<
<
2
;
const
Byte
kSolid
=
1
<
<
4
;
}
const
UInt64
k_SolidBig_Resource_Marker
=
(
UInt64
)
1
<
<
32
;
struct
CResource
{
UInt64
PackSize
;
UInt64
Offset
;
UInt64
UnpackSize
;
Byte
Flags
;
bool
KeepSolid
;
int
SolidIndex
;
void
Clear
(
)
{
PackSize
=
0
;
Offset
=
0
;
UnpackSize
=
0
;
Flags
=
0
;
KeepSolid
=
false
;
SolidIndex
=
-
1
;
}
UInt64
GetEndLimit
(
)
const
{
return
Offset
+
PackSize
;
}
void
Parse
(
const
Byte
*
p
)
;
void
ParseAndUpdatePhySize
(
const
Byte
*
p
UInt64
&
phySize
)
{
Parse
(
p
)
;
UInt64
v
=
GetEndLimit
(
)
;
if
(
phySize
<
v
)
phySize
=
v
;
}
void
WriteTo
(
Byte
*
p
)
const
;
bool
IsMetadata
(
)
const
{
return
(
Flags
&
NResourceFlags
:
:
kMetadata
)
!
=
0
;
}
bool
IsCompressed
(
)
const
{
return
(
Flags
&
NResourceFlags
:
:
kCompressed
)
!
=
0
;
}
bool
IsSolid
(
)
const
{
return
(
Flags
&
NResourceFlags
:
:
kSolid
)
!
=
0
;
}
bool
IsSolidBig
(
)
const
{
return
IsSolid
(
)
&
&
UnpackSize
=
=
k_SolidBig_Resource_Marker
;
}
bool
IsSolidSmall
(
)
const
{
return
IsSolid
(
)
&
&
UnpackSize
=
=
0
;
}
bool
IsEmpty
(
)
const
{
return
(
UnpackSize
=
=
0
)
;
}
}
;
struct
CSolid
{
unsigned
StreamIndex
;
int
FirstSmallStream
;
UInt64
SolidOffset
;
UInt64
UnpackSize
;
int
Method
;
int
ChunkSizeBits
;
UInt64
HeadersSize
;
CObjArray
<
UInt64
>
Chunks
;
UInt64
GetChunkPackSize
(
size_t
chunkIndex
)
const
{
return
Chunks
[
chunkIndex
+
1
]
-
Chunks
[
chunkIndex
]
;
}
CSolid
(
)
:
FirstSmallStream
(
-
1
)
Method
(
-
1
)
{
}
}
;
namespace
NHeaderFlags
{
const
UInt32
kCompression
=
1
<
<
1
;
const
UInt32
kReadOnly
=
1
<
<
2
;
const
UInt32
kSpanned
=
1
<
<
3
;
const
UInt32
kResourceOnly
=
1
<
<
4
;
const
UInt32
kMetadataOnly
=
1
<
<
5
;
const
UInt32
kWriteInProgress
=
1
<
<
6
;
const
UInt32
kReparsePointFixup
=
1
<
<
7
;
const
UInt32
kXPRESS
=
(
UInt32
)
1
<
<
17
;
const
UInt32
kLZX
=
(
UInt32
)
1
<
<
18
;
const
UInt32
kLZMS
=
(
UInt32
)
1
<
<
19
;
const
UInt32
kXPRESS2
=
(
UInt32
)
1
<
<
21
;
const
UInt32
kMethodMask
=
0xFFFE0000
;
}
namespace
NMethod
{
const
UInt32
kXPRESS
=
1
;
const
UInt32
kLZX
=
2
;
const
UInt32
kLZMS
=
3
;
}
const
UInt32
k_Version_NonSolid
=
0x10D00
;
const
UInt32
k_Version_Solid
=
0xE00
;
const
unsigned
kHeaderSizeMax
=
0xD0
;
const
unsigned
kSignatureSize
=
8
;
extern
const
Byte
kSignature
[
kSignatureSize
]
;
const
unsigned
kChunkSizeBits
=
15
;
const
UInt32
kChunkSize
=
(
UInt32
)
1
<
<
kChunkSizeBits
;
struct
CHeader
{
UInt32
Version
;
UInt32
Flags
;
UInt32
ChunkSize
;
unsigned
ChunkSizeBits
;
Byte
Guid
[
16
]
;
UInt16
PartNumber
;
UInt16
NumParts
;
UInt32
NumImages
;
UInt32
BootIndex
;
bool
_IsOldVersion
;
bool
_IsNewVersion
;
CResource
OffsetResource
;
CResource
XmlResource
;
CResource
MetadataResource
;
CResource
IntegrityResource
;
void
SetDefaultFields
(
bool
useLZX
)
;
void
WriteTo
(
Byte
*
p
)
const
;
HRESULT
Parse
(
const
Byte
*
p
UInt64
&
phySize
)
;
bool
IsCompressed
(
)
const
{
return
(
Flags
&
NHeaderFlags
:
:
kCompression
)
!
=
0
;
}
bool
IsSupported
(
)
const
{
return
(
!
IsCompressed
(
)
|
|
(
Flags
&
NHeaderFlags
:
:
kLZX
)
!
=
0
|
|
(
Flags
&
NHeaderFlags
:
:
kXPRESS
)
!
=
0
|
|
(
Flags
&
NHeaderFlags
:
:
kLZMS
)
!
=
0
|
|
(
Flags
&
NHeaderFlags
:
:
kXPRESS2
)
!
=
0
)
;
}
unsigned
GetMethod
(
)
const
{
if
(
!
IsCompressed
(
)
)
return
0
;
UInt32
mask
=
(
Flags
&
NHeaderFlags
:
:
kMethodMask
)
;
if
(
mask
=
=
0
)
return
0
;
if
(
mask
=
=
NHeaderFlags
:
:
kXPRESS
)
return
NMethod
:
:
kXPRESS
;
if
(
mask
=
=
NHeaderFlags
:
:
kLZX
)
return
NMethod
:
:
kLZX
;
if
(
mask
=
=
NHeaderFlags
:
:
kLZMS
)
return
NMethod
:
:
kLZMS
;
if
(
mask
=
=
NHeaderFlags
:
:
kXPRESS2
)
return
NMethod
:
:
kXPRESS
;
return
mask
;
}
bool
IsOldVersion
(
)
const
{
return
_IsOldVersion
;
}
bool
IsNewVersion
(
)
const
{
return
_IsNewVersion
;
}
bool
IsSolidVersion
(
)
const
{
return
(
Version
=
=
k_Version_Solid
)
;
}
bool
AreFromOnArchive
(
const
CHeader
&
h
)
{
return
(
memcmp
(
Guid
h
.
Guid
sizeof
(
Guid
)
)
=
=
0
)
&
&
(
h
.
NumParts
=
=
NumParts
)
;
}
}
;
const
unsigned
kHashSize
=
20
;
inline
bool
IsEmptySha
(
const
Byte
*
data
)
{
for
(
unsigned
i
=
0
;
i
<
kHashSize
;
i
+
+
)
if
(
data
[
i
]
!
=
0
)
return
false
;
return
true
;
}
const
unsigned
kStreamInfoSize
=
24
+
2
+
4
+
kHashSize
;
struct
CStreamInfo
{
CResource
Resource
;
UInt16
PartNumber
;
UInt32
RefCount
;
UInt32
Id
;
Byte
Hash
[
kHashSize
]
;
bool
IsEmptyHash
(
)
const
{
return
IsEmptySha
(
Hash
)
;
}
void
WriteTo
(
Byte
*
p
)
const
;
}
;
struct
CItem
{
size_t
Offset
;
int
IndexInSorted
;
int
StreamIndex
;
int
Parent
;
int
ImageIndex
;
bool
IsDir
;
bool
IsAltStream
;
bool
HasMetadata
(
)
const
{
return
ImageIndex
>
=
0
;
}
CItem
(
)
:
IndexInSorted
(
-
1
)
StreamIndex
(
-
1
)
Parent
(
-
1
)
IsDir
(
false
)
IsAltStream
(
false
)
{
}
}
;
struct
CImage
{
CByteBuffer
Meta
;
CRecordVector
<
UInt32
>
SecurOffsets
;
unsigned
StartItem
;
unsigned
NumItems
;
unsigned
NumEmptyRootItems
;
int
VirtualRootIndex
;
UString
RootName
;
CByteBuffer
RootNameBuf
;
CImage
(
)
:
VirtualRootIndex
(
-
1
)
{
}
}
;
struct
CImageInfo
{
bool
CTimeDefined
;
bool
MTimeDefined
;
bool
NameDefined
;
bool
IndexDefined
;
FILETIME
CTime
;
FILETIME
MTime
;
UString
Name
;
UInt64
DirCount
;
UInt64
FileCount
;
UInt32
Index
;
int
ItemIndexInXml
;
UInt64
GetTotalFilesAndDirs
(
)
const
{
return
DirCount
+
FileCount
;
}
CImageInfo
(
)
:
CTimeDefined
(
false
)
MTimeDefined
(
false
)
NameDefined
(
false
)
IndexDefined
(
false
)
ItemIndexInXml
(
-
1
)
{
}
void
Parse
(
const
CXmlItem
&
item
)
;
}
;
struct
CWimXml
{
CByteBuffer
Data
;
CXml
Xml
;
UInt16
VolIndex
;
CObjectVector
<
CImageInfo
>
Images
;
UString
FileName
;
bool
IsEncrypted
;
UInt64
GetTotalFilesAndDirs
(
)
const
{
UInt64
sum
=
0
;
FOR_VECTOR
(
i
Images
)
sum
+
=
Images
[
i
]
.
GetTotalFilesAndDirs
(
)
;
return
sum
;
}
void
ToUnicode
(
UString
&
s
)
;
bool
Parse
(
)
;
CWimXml
(
)
:
IsEncrypted
(
false
)
{
}
}
;
struct
CVolume
{
CHeader
Header
;
CMyComPtr
<
IInStream
>
Stream
;
}
;
class
CDatabase
{
Byte
*
DirData
;
size_t
DirSize
;
size_t
DirProcessed
;
size_t
DirStartOffset
;
IArchiveOpenCallback
*
OpenCallback
;
HRESULT
ParseDirItem
(
size_t
pos
int
parent
)
;
HRESULT
ParseImageDirs
(
CByteBuffer
&
buf
int
parent
)
;
public
:
CRecordVector
<
CStreamInfo
>
DataStreams
;
CRecordVector
<
CStreamInfo
>
MetaStreams
;
CObjectVector
<
CSolid
>
Solids
;
CRecordVector
<
CItem
>
Items
;
CObjectVector
<
CByteBuffer
>
ReparseItems
;
CIntVector
ItemToReparse
;
CObjectVector
<
CImage
>
Images
;
bool
IsOldVersion9
;
bool
IsOldVersion
;
bool
ThereAreDeletedStreams
;
bool
ThereAreAltStreams
;
bool
RefCountError
;
bool
HeadersError
;
bool
GetStartImageIndex
(
)
const
{
return
IsOldVersion9
?
0
:
1
;
}
unsigned
GetDirAlignMask
(
)
const
{
return
IsOldVersion9
?
3
:
7
;
}
CUIntVector
SortedItems
;
int
IndexOfUserImage
;
unsigned
NumExcludededItems
;
int
ExludedItem
;
CUIntVector
VirtualRoots
;
bool
ThereIsError
(
)
const
{
return
RefCountError
;
}
unsigned
GetNumUserItemsInImage
(
unsigned
imageIndex
)
const
{
if
(
IndexOfUserImage
>
=
0
&
&
imageIndex
!
=
(
unsigned
)
IndexOfUserImage
)
return
0
;
if
(
imageIndex
>
=
Images
.
Size
(
)
)
return
0
;
return
Images
[
imageIndex
]
.
NumItems
-
NumExcludededItems
;
}
bool
ItemHasStream
(
const
CItem
&
item
)
const
;
UInt64
Get_UnpackSize_of_Resource
(
const
CResource
&
r
)
const
{
if
(
!
r
.
IsSolid
(
)
)
return
r
.
UnpackSize
;
if
(
r
.
IsSolidSmall
(
)
)
return
r
.
PackSize
;
if
(
r
.
IsSolidBig
(
)
&
&
r
.
SolidIndex
>
=
0
)
return
Solids
[
(
unsigned
)
r
.
SolidIndex
]
.
UnpackSize
;
return
0
;
}
UInt64
Get_PackSize_of_Resource
(
unsigned
streamIndex
)
const
{
const
CResource
&
r
=
DataStreams
[
streamIndex
]
.
Resource
;
if
(
!
r
.
IsSolidSmall
(
)
)
return
r
.
PackSize
;
if
(
r
.
SolidIndex
>
=
0
)
{
const
CSolid
&
ss
=
Solids
[
(
unsigned
)
r
.
SolidIndex
]
;
if
(
ss
.
FirstSmallStream
=
=
(
int
)
streamIndex
)
return
DataStreams
[
ss
.
StreamIndex
]
.
Resource
.
PackSize
;
}
return
0
;
}
UInt64
GetUnpackSize
(
)
const
{
UInt64
res
=
0
;
FOR_VECTOR
(
i
DataStreams
)
res
+
=
DataStreams
[
i
]
.
Resource
.
UnpackSize
;
return
res
;
}
UInt64
GetPackSize
(
)
const
{
UInt64
res
=
0
;
FOR_VECTOR
(
i
DataStreams
)
res
+
=
DataStreams
[
i
]
.
Resource
.
PackSize
;
return
res
;
}
void
Clear
(
)
{
DataStreams
.
Clear
(
)
;
MetaStreams
.
Clear
(
)
;
Solids
.
Clear
(
)
;
Items
.
Clear
(
)
;
ReparseItems
.
Clear
(
)
;
ItemToReparse
.
Clear
(
)
;
SortedItems
.
Clear
(
)
;
Images
.
Clear
(
)
;
VirtualRoots
.
Clear
(
)
;
IsOldVersion
=
false
;
ThereAreDeletedStreams
=
false
;
ThereAreAltStreams
=
false
;
RefCountError
=
false
;
HeadersError
=
false
;
}
CDatabase
(
)
:
RefCountError
(
false
)
{
}
void
GetShortName
(
unsigned
index
NWindows
:
:
NCOM
:
:
CPropVariant
&
res
)
const
;
void
GetItemName
(
unsigned
index1
NWindows
:
:
NCOM
:
:
CPropVariant
&
res
)
const
;
void
GetItemPath
(
unsigned
index
bool
showImageNumber
NWindows
:
:
NCOM
:
:
CPropVariant
&
res
)
const
;
HRESULT
OpenXml
(
IInStream
*
inStream
const
CHeader
&
h
CByteBuffer
&
xml
)
;
HRESULT
Open
(
IInStream
*
inStream
const
CHeader
&
h
unsigned
numItemsReserve
IArchiveOpenCallback
*
openCallback
)
;
HRESULT
FillAndCheck
(
const
CObjectVector
<
CVolume
>
&
volumes
)
;
HRESULT
GenerateSortedItems
(
int
imageIndex
bool
showImageNumber
)
;
HRESULT
ExtractReparseStreams
(
const
CObjectVector
<
CVolume
>
&
volumes
IArchiveOpenCallback
*
openCallback
)
;
}
;
HRESULT
ReadHeader
(
IInStream
*
inStream
CHeader
&
header
UInt64
&
phySize
)
;
struct
CMidBuf
{
Byte
*
Data
;
size_t
_size
;
CMidBuf
(
)
:
Data
(
NULL
)
_size
(
0
)
{
}
void
EnsureCapacity
(
size_t
size
)
{
if
(
size
>
_size
)
{
:
:
MidFree
(
Data
)
;
_size
=
0
;
Data
=
(
Byte
*
)
:
:
MidAlloc
(
size
)
;
if
(
Data
)
_size
=
size
;
}
}
~
CMidBuf
(
)
{
:
:
MidFree
(
Data
)
;
}
}
;
class
CUnpacker
{
NCompress
:
:
CCopyCoder
*
copyCoderSpec
;
CMyComPtr
<
ICompressCoder
>
copyCoder
;
NCompress
:
:
NLzx
:
:
CDecoder
*
lzxDecoderSpec
;
CMyComPtr
<
IUnknown
>
lzxDecoder
;
NCompress
:
:
NLzms
:
:
CDecoder
*
lzmsDecoder
;
CByteBuffer
sizesBuf
;
CMidBuf
packBuf
;
CMidBuf
unpackBuf
;
int
_solidIndex
;
size_t
_unpackedChunkIndex
;
HRESULT
UnpackChunk
(
ISequentialInStream
*
inStream
unsigned
method
unsigned
chunkSizeBits
size_t
inSize
size_t
outSize
ISequentialOutStream
*
outStream
)
;
HRESULT
Unpack2
(
IInStream
*
inStream
const
CResource
&
res
const
CHeader
&
header
const
CDatabase
*
db
ISequentialOutStream
*
outStream
ICompressProgressInfo
*
progress
)
;
public
:
UInt64
TotalPacked
;
CUnpacker
(
)
:
lzmsDecoder
(
NULL
)
_solidIndex
(
-
1
)
_unpackedChunkIndex
(
0
)
TotalPacked
(
0
)
{
}
~
CUnpacker
(
)
;
HRESULT
Unpack
(
IInStream
*
inStream
const
CResource
&
res
const
CHeader
&
header
const
CDatabase
*
db
ISequentialOutStream
*
outStream
ICompressProgressInfo
*
progress
Byte
*
digest
)
;
HRESULT
UnpackData
(
IInStream
*
inStream
const
CResource
&
resource
const
CHeader
&
header
const
CDatabase
*
db
CByteBuffer
&
buf
Byte
*
digest
)
;
}
;
}
}
#
endif
