#
ifndef
THIRD_PARTY_SNAPPY_OPENSOURCE_SNAPPY_TEST_H_
#
define
THIRD_PARTY_SNAPPY_OPENSOURCE_SNAPPY_TEST_H_
#
ifdef
HAVE_CONFIG_H
#
include
"
config
.
h
"
#
endif
#
include
"
snappy
-
stubs
-
internal
.
h
"
#
ifdef
HAVE_SYS_MMAN_H
#
include
<
sys
/
mman
.
h
>
#
endif
#
ifdef
HAVE_SYS_RESOURCE_H
#
include
<
sys
/
resource
.
h
>
#
endif
#
ifdef
HAVE_SYS_TIME_H
#
include
<
sys
/
time
.
h
>
#
endif
#
ifdef
HAVE_WINDOWS_H
#
define
NOMINMAX
#
include
<
windows
.
h
>
#
endif
#
define
InitGoogle
(
argv0
argc
argv
remove_flags
)
(
(
void
)
(
0
)
)
#
ifdef
HAVE_LIBZ
#
include
"
zlib
.
h
"
#
endif
#
ifdef
HAVE_LIBLZO2
#
include
"
lzo
/
lzo1x
.
h
"
#
endif
#
ifdef
HAVE_LIBLZ4
#
include
"
lz4
.
h
"
#
endif
namespace
file
{
class
OptionsStub
{
public
:
OptionsStub
(
)
;
OptionsStub
(
const
OptionsStub
&
)
=
delete
;
OptionsStub
&
operator
=
(
const
OptionsStub
&
)
=
delete
;
~
OptionsStub
(
)
;
}
;
const
OptionsStub
&
Defaults
(
)
;
class
StatusStub
{
public
:
StatusStub
(
)
;
StatusStub
(
const
StatusStub
&
)
;
StatusStub
&
operator
=
(
const
StatusStub
&
)
;
~
StatusStub
(
)
;
bool
ok
(
)
;
}
;
StatusStub
GetContents
(
const
std
:
:
string
&
file_name
std
:
:
string
*
output
const
OptionsStub
&
)
;
StatusStub
SetContents
(
const
std
:
:
string
&
file_name
const
std
:
:
string
&
content
const
OptionsStub
&
)
;
}
namespace
snappy
{
#
define
FLAGS_test_random_seed
301
std
:
:
string
ReadTestDataFile
(
const
std
:
:
string
&
base
size_t
size_limit
)
;
std
:
:
string
StrFormat
(
const
char
*
format
.
.
.
)
;
class
CycleTimer
{
public
:
inline
CycleTimer
(
)
:
real_time_us_
(
0
)
{
}
inline
~
CycleTimer
(
)
=
default
;
inline
void
Start
(
)
{
#
ifdef
WIN32
QueryPerformanceCounter
(
&
start_
)
;
#
else
:
:
gettimeofday
(
&
start_
nullptr
)
;
#
endif
}
inline
void
Stop
(
)
{
#
ifdef
WIN32
LARGE_INTEGER
stop
;
LARGE_INTEGER
frequency
;
QueryPerformanceCounter
(
&
stop
)
;
QueryPerformanceFrequency
(
&
frequency
)
;
double
elapsed
=
static_cast
<
double
>
(
stop
.
QuadPart
-
start_
.
QuadPart
)
/
frequency
.
QuadPart
;
real_time_us_
+
=
elapsed
*
1e6
+
0
.
5
;
#
else
struct
:
:
timeval
stop
;
:
:
gettimeofday
(
&
stop
nullptr
)
;
real_time_us_
+
=
1000000
*
(
stop
.
tv_sec
-
start_
.
tv_sec
)
;
real_time_us_
+
=
(
stop
.
tv_usec
-
start_
.
tv_usec
)
;
#
endif
}
inline
double
Get
(
)
{
return
real_time_us_
*
1e
-
6
;
}
private
:
int64_t
real_time_us_
;
#
ifdef
WIN32
LARGE_INTEGER
start_
;
#
else
struct
:
:
timeval
start_
;
#
endif
}
;
class
LogMessage
{
public
:
inline
LogMessage
(
)
=
default
;
~
LogMessage
(
)
;
LogMessage
&
operator
<
<
(
const
std
:
:
string
&
message
)
;
LogMessage
&
operator
<
<
(
int
number
)
;
}
;
class
LogMessageCrash
:
public
LogMessage
{
public
:
inline
LogMessageCrash
(
)
=
default
;
~
LogMessageCrash
(
)
;
}
;
class
LogMessageVoidify
{
public
:
inline
LogMessageVoidify
(
)
=
default
;
inline
~
LogMessageVoidify
(
)
=
default
;
inline
void
operator
&
(
const
LogMessage
&
)
{
}
}
;
#
define
CRASH_UNLESS
(
condition
)
\
SNAPPY_PREDICT_TRUE
(
condition
)
\
?
(
void
)
0
\
:
snappy
:
:
LogMessageVoidify
(
)
&
snappy
:
:
LogMessageCrash
(
)
#
define
LOG
(
level
)
LogMessage
(
)
#
define
VLOG
(
level
)
\
true
?
(
void
)
0
:
snappy
:
:
LogMessageVoidify
(
)
&
snappy
:
:
LogMessage
(
)
#
define
CHECK
(
cond
)
CRASH_UNLESS
(
cond
)
#
define
CHECK_LE
(
a
b
)
CRASH_UNLESS
(
(
a
)
<
=
(
b
)
)
#
define
CHECK_GE
(
a
b
)
CRASH_UNLESS
(
(
a
)
>
=
(
b
)
)
#
define
CHECK_EQ
(
a
b
)
CRASH_UNLESS
(
(
a
)
=
=
(
b
)
)
#
define
CHECK_NE
(
a
b
)
CRASH_UNLESS
(
(
a
)
!
=
(
b
)
)
#
define
CHECK_LT
(
a
b
)
CRASH_UNLESS
(
(
a
)
<
(
b
)
)
#
define
CHECK_GT
(
a
b
)
CRASH_UNLESS
(
(
a
)
>
(
b
)
)
#
define
CHECK_OK
(
cond
)
(
cond
)
.
ok
(
)
#
ifdef
HAVE_LIBZ
class
ZLib
{
public
:
ZLib
(
)
;
~
ZLib
(
)
;
void
Reinit
(
)
;
void
Reset
(
)
;
static
int
MinCompressbufSize
(
int
uncompress_size
)
{
return
uncompress_size
+
uncompress_size
/
1000
+
40
;
}
int
Compress
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
sourceLen
)
;
int
Uncompress
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
sourceLen
)
;
int
UncompressAtMost
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
*
sourceLen
)
;
bool
UncompressChunkDone
(
)
;
private
:
int
InflateInit
(
)
;
int
DeflateInit
(
)
;
int
CompressInit
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
*
sourceLen
)
;
int
UncompressInit
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
*
sourceLen
)
;
void
UncompressErrorInit
(
)
;
int
CompressChunkOrAll
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
sourceLen
int
flush_mode
)
;
int
CompressAtMostOrAll
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
*
sourceLen
int
flush_mode
)
;
int
UncompressChunkOrAll
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
sourceLen
int
flush_mode
)
;
int
UncompressAtMostOrAll
(
Bytef
*
dest
uLongf
*
destLen
const
Bytef
*
source
uLong
*
sourceLen
int
flush_mode
)
;
void
CompressErrorInit
(
)
;
int
compression_level_
;
int
window_bits_
;
int
mem_level_
;
z_stream
comp_stream_
;
bool
comp_init_
;
z_stream
uncomp_stream_
;
bool
uncomp_init_
;
bool
first_chunk_
;
}
;
#
endif
}
#
endif
