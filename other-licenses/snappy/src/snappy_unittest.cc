#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
cstdlib
>
#
include
<
random
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
snappy
-
test
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
snappy
-
internal
.
h
"
#
include
"
snappy
-
sinksource
.
h
"
#
include
"
snappy
.
h
"
#
include
"
snappy_test_data
.
h
"
SNAPPY_FLAG
(
bool
snappy_dump_decompression_table
false
"
If
true
we
print
the
decompression
table
during
tests
.
"
)
;
namespace
snappy
{
namespace
{
#
if
defined
(
HAVE_FUNC_MMAP
)
&
&
defined
(
HAVE_FUNC_SYSCONF
)
class
DataEndingAtUnreadablePage
{
public
:
explicit
DataEndingAtUnreadablePage
(
const
std
:
:
string
&
s
)
{
const
size_t
page_size
=
sysconf
(
_SC_PAGESIZE
)
;
const
size_t
size
=
s
.
size
(
)
;
size_t
space_for_string
=
(
size
+
page_size
-
1
)
&
~
(
page_size
-
1
)
;
alloc_size_
=
space_for_string
+
page_size
;
mem_
=
mmap
(
NULL
alloc_size_
PROT_READ
|
PROT_WRITE
MAP_PRIVATE
|
MAP_ANONYMOUS
-
1
0
)
;
CHECK_NE
(
MAP_FAILED
mem_
)
;
protected_page_
=
reinterpret_cast
<
char
*
>
(
mem_
)
+
space_for_string
;
char
*
dst
=
protected_page_
-
size
;
std
:
:
memcpy
(
dst
s
.
data
(
)
size
)
;
data_
=
dst
;
size_
=
size
;
CHECK_EQ
(
0
mprotect
(
protected_page_
page_size
PROT_NONE
)
)
;
}
~
DataEndingAtUnreadablePage
(
)
{
const
size_t
page_size
=
sysconf
(
_SC_PAGESIZE
)
;
CHECK_EQ
(
0
mprotect
(
protected_page_
page_size
PROT_READ
|
PROT_WRITE
)
)
;
CHECK_EQ
(
0
munmap
(
mem_
alloc_size_
)
)
;
}
const
char
*
data
(
)
const
{
return
data_
;
}
size_t
size
(
)
const
{
return
size_
;
}
private
:
size_t
alloc_size_
;
void
*
mem_
;
char
*
protected_page_
;
const
char
*
data_
;
size_t
size_
;
}
;
#
else
using
DataEndingAtUnreadablePage
=
std
:
:
string
;
#
endif
int
VerifyString
(
const
std
:
:
string
&
input
)
{
std
:
:
string
compressed
;
DataEndingAtUnreadablePage
i
(
input
)
;
const
size_t
written
=
snappy
:
:
Compress
(
i
.
data
(
)
i
.
size
(
)
&
compressed
)
;
CHECK_EQ
(
written
compressed
.
size
(
)
)
;
CHECK_LE
(
compressed
.
size
(
)
snappy
:
:
MaxCompressedLength
(
input
.
size
(
)
)
)
;
CHECK
(
snappy
:
:
IsValidCompressedBuffer
(
compressed
.
data
(
)
compressed
.
size
(
)
)
)
;
std
:
:
string
uncompressed
;
DataEndingAtUnreadablePage
c
(
compressed
)
;
CHECK
(
snappy
:
:
Uncompress
(
c
.
data
(
)
c
.
size
(
)
&
uncompressed
)
)
;
CHECK_EQ
(
uncompressed
input
)
;
return
uncompressed
.
size
(
)
;
}
void
VerifyStringSink
(
const
std
:
:
string
&
input
)
{
std
:
:
string
compressed
;
DataEndingAtUnreadablePage
i
(
input
)
;
const
size_t
written
=
snappy
:
:
Compress
(
i
.
data
(
)
i
.
size
(
)
&
compressed
)
;
CHECK_EQ
(
written
compressed
.
size
(
)
)
;
CHECK_LE
(
compressed
.
size
(
)
snappy
:
:
MaxCompressedLength
(
input
.
size
(
)
)
)
;
CHECK
(
snappy
:
:
IsValidCompressedBuffer
(
compressed
.
data
(
)
compressed
.
size
(
)
)
)
;
std
:
:
string
uncompressed
;
uncompressed
.
resize
(
input
.
size
(
)
)
;
snappy
:
:
UncheckedByteArraySink
sink
(
string_as_array
(
&
uncompressed
)
)
;
DataEndingAtUnreadablePage
c
(
compressed
)
;
snappy
:
:
ByteArraySource
source
(
c
.
data
(
)
c
.
size
(
)
)
;
CHECK
(
snappy
:
:
Uncompress
(
&
source
&
sink
)
)
;
CHECK_EQ
(
uncompressed
input
)
;
}
void
VerifyIOVec
(
const
std
:
:
string
&
input
)
{
std
:
:
string
compressed
;
DataEndingAtUnreadablePage
i
(
input
)
;
const
size_t
written
=
snappy
:
:
Compress
(
i
.
data
(
)
i
.
size
(
)
&
compressed
)
;
CHECK_EQ
(
written
compressed
.
size
(
)
)
;
CHECK_LE
(
compressed
.
size
(
)
snappy
:
:
MaxCompressedLength
(
input
.
size
(
)
)
)
;
CHECK
(
snappy
:
:
IsValidCompressedBuffer
(
compressed
.
data
(
)
compressed
.
size
(
)
)
)
;
char
*
buf
=
new
char
[
input
.
size
(
)
]
;
std
:
:
minstd_rand0
rng
(
input
.
size
(
)
)
;
std
:
:
uniform_int_distribution
<
size_t
>
uniform_1_to_10
(
1
10
)
;
size_t
num
=
uniform_1_to_10
(
rng
)
;
if
(
input
.
size
(
)
<
num
)
{
num
=
input
.
size
(
)
;
}
struct
iovec
*
iov
=
new
iovec
[
num
]
;
size_t
used_so_far
=
0
;
std
:
:
bernoulli_distribution
one_in_five
(
1
.
0
/
5
)
;
for
(
size_t
i
=
0
;
i
<
num
;
+
+
i
)
{
assert
(
used_so_far
<
input
.
size
(
)
)
;
iov
[
i
]
.
iov_base
=
buf
+
used_so_far
;
if
(
i
=
=
num
-
1
)
{
iov
[
i
]
.
iov_len
=
input
.
size
(
)
-
used_so_far
;
}
else
{
if
(
one_in_five
(
rng
)
)
{
iov
[
i
]
.
iov_len
=
0
;
}
else
{
std
:
:
uniform_int_distribution
<
size_t
>
uniform_not_used_so_far
(
0
input
.
size
(
)
-
used_so_far
-
1
)
;
iov
[
i
]
.
iov_len
=
uniform_not_used_so_far
(
rng
)
;
}
}
used_so_far
+
=
iov
[
i
]
.
iov_len
;
}
CHECK
(
snappy
:
:
RawUncompressToIOVec
(
compressed
.
data
(
)
compressed
.
size
(
)
iov
num
)
)
;
CHECK
(
!
memcmp
(
buf
input
.
data
(
)
input
.
size
(
)
)
)
;
delete
[
]
iov
;
delete
[
]
buf
;
}
void
VerifyNonBlockedCompression
(
const
std
:
:
string
&
input
)
{
if
(
input
.
length
(
)
>
snappy
:
:
kBlockSize
)
{
return
;
}
std
:
:
string
prefix
;
Varint
:
:
Append32
(
&
prefix
input
.
size
(
)
)
;
snappy
:
:
internal
:
:
WorkingMemory
wmem
(
input
.
size
(
)
)
;
int
table_size
;
uint16_t
*
table
=
wmem
.
GetHashTable
(
input
.
size
(
)
&
table_size
)
;
std
:
:
string
compressed
;
compressed
+
=
prefix
;
compressed
.
resize
(
prefix
.
size
(
)
+
snappy
:
:
MaxCompressedLength
(
input
.
size
(
)
)
)
;
char
*
dest
=
string_as_array
(
&
compressed
)
+
prefix
.
size
(
)
;
char
*
end
=
snappy
:
:
internal
:
:
CompressFragment
(
input
.
data
(
)
input
.
size
(
)
dest
table
table_size
)
;
compressed
.
resize
(
end
-
compressed
.
data
(
)
)
;
std
:
:
string
uncomp_str
;
CHECK
(
snappy
:
:
Uncompress
(
compressed
.
data
(
)
compressed
.
size
(
)
&
uncomp_str
)
)
;
CHECK_EQ
(
uncomp_str
input
)
;
std
:
:
string
uncomp_str2
;
uncomp_str2
.
resize
(
input
.
size
(
)
)
;
snappy
:
:
UncheckedByteArraySink
sink
(
string_as_array
(
&
uncomp_str2
)
)
;
snappy
:
:
ByteArraySource
source
(
compressed
.
data
(
)
compressed
.
size
(
)
)
;
CHECK
(
snappy
:
:
Uncompress
(
&
source
&
sink
)
)
;
CHECK_EQ
(
uncomp_str2
input
)
;
{
static
const
int
kNumBlocks
=
10
;
struct
iovec
vec
[
kNumBlocks
]
;
const
int
block_size
=
1
+
input
.
size
(
)
/
kNumBlocks
;
std
:
:
string
iovec_data
(
block_size
*
kNumBlocks
'
x
'
)
;
for
(
int
i
=
0
;
i
<
kNumBlocks
;
+
+
i
)
{
vec
[
i
]
.
iov_base
=
string_as_array
(
&
iovec_data
)
+
i
*
block_size
;
vec
[
i
]
.
iov_len
=
block_size
;
}
CHECK
(
snappy
:
:
RawUncompressToIOVec
(
compressed
.
data
(
)
compressed
.
size
(
)
vec
kNumBlocks
)
)
;
CHECK_EQ
(
std
:
:
string
(
iovec_data
.
data
(
)
input
.
size
(
)
)
input
)
;
}
}
std
:
:
string
Expand
(
const
std
:
:
string
&
input
)
{
static
const
int
K
=
3
;
std
:
:
string
data
=
input
;
while
(
data
.
size
(
)
<
K
*
snappy
:
:
kBlockSize
)
{
data
+
=
input
;
}
return
data
;
}
int
Verify
(
const
std
:
:
string
&
input
)
{
VLOG
(
1
)
<
<
"
Verifying
input
of
size
"
<
<
input
.
size
(
)
;
const
int
result
=
VerifyString
(
input
)
;
VerifyStringSink
(
input
)
;
VerifyNonBlockedCompression
(
input
)
;
VerifyIOVec
(
input
)
;
if
(
!
input
.
empty
(
)
)
{
const
std
:
:
string
expanded
=
Expand
(
input
)
;
VerifyNonBlockedCompression
(
expanded
)
;
VerifyIOVec
(
input
)
;
}
return
result
;
}
bool
IsValidCompressedBuffer
(
const
std
:
:
string
&
c
)
{
return
snappy
:
:
IsValidCompressedBuffer
(
c
.
data
(
)
c
.
size
(
)
)
;
}
bool
Uncompress
(
const
std
:
:
string
&
c
std
:
:
string
*
u
)
{
return
snappy
:
:
Uncompress
(
c
.
data
(
)
c
.
size
(
)
u
)
;
}
TEST
(
CorruptedTest
VerifyCorrupted
)
{
std
:
:
string
source
=
"
making
sure
we
don
'
t
crash
with
corrupted
input
"
;
VLOG
(
1
)
<
<
source
;
std
:
:
string
dest
;
std
:
:
string
uncmp
;
snappy
:
:
Compress
(
source
.
data
(
)
source
.
size
(
)
&
dest
)
;
CHECK_GT
(
dest
.
size
(
)
3
)
;
dest
[
1
]
-
-
;
dest
[
3
]
+
+
;
CHECK
(
!
IsValidCompressedBuffer
(
dest
)
)
;
CHECK
(
!
Uncompress
(
dest
&
uncmp
)
)
;
source
.
resize
(
100000
)
;
for
(
char
&
source_char
:
source
)
{
source_char
=
'
A
'
;
}
snappy
:
:
Compress
(
source
.
data
(
)
source
.
size
(
)
&
dest
)
;
dest
[
0
]
=
dest
[
1
]
=
dest
[
2
]
=
dest
[
3
]
=
0
;
CHECK
(
!
IsValidCompressedBuffer
(
dest
)
)
;
CHECK
(
!
Uncompress
(
dest
&
uncmp
)
)
;
if
(
sizeof
(
void
*
)
=
=
4
)
{
dest
[
0
]
=
dest
[
1
]
=
dest
[
2
]
=
dest
[
3
]
=
'
\
xff
'
;
dest
[
4
]
=
'
k
'
;
CHECK
(
!
IsValidCompressedBuffer
(
dest
)
)
;
CHECK
(
!
Uncompress
(
dest
&
uncmp
)
)
;
}
else
{
LOG
(
WARNING
)
<
<
"
Crazy
decompression
lengths
not
checked
on
64
-
bit
build
"
;
}
dest
[
0
]
=
dest
[
1
]
=
dest
[
2
]
=
'
\
xff
'
;
dest
[
3
]
=
0x00
;
CHECK
(
!
IsValidCompressedBuffer
(
dest
)
)
;
CHECK
(
!
Uncompress
(
dest
&
uncmp
)
)
;
for
(
int
i
=
1
;
i
<
=
3
;
+
+
i
)
{
std
:
:
string
data
=
ReadTestDataFile
(
StrFormat
(
"
baddata
%
d
.
snappy
"
i
)
.
c_str
(
)
0
)
;
std
:
:
string
uncmp
;
size_t
ulen
;
CHECK
(
!
snappy
:
:
GetUncompressedLength
(
data
.
data
(
)
data
.
size
(
)
&
ulen
)
|
|
(
ulen
<
(
1
<
<
20
)
)
)
;
uint32_t
ulen2
;
snappy
:
:
ByteArraySource
source
(
data
.
data
(
)
data
.
size
(
)
)
;
CHECK
(
!
snappy
:
:
GetUncompressedLength
(
&
source
&
ulen2
)
|
|
(
ulen2
<
(
1
<
<
20
)
)
)
;
CHECK
(
!
IsValidCompressedBuffer
(
data
)
)
;
CHECK
(
!
Uncompress
(
data
&
uncmp
)
)
;
}
}
void
AppendLiteral
(
std
:
:
string
*
dst
const
std
:
:
string
&
literal
)
{
if
(
literal
.
empty
(
)
)
return
;
int
n
=
literal
.
size
(
)
-
1
;
if
(
n
<
60
)
{
dst
-
>
push_back
(
0
|
(
n
<
<
2
)
)
;
}
else
{
char
number
[
4
]
;
int
count
=
0
;
while
(
n
>
0
)
{
number
[
count
+
+
]
=
n
&
0xff
;
n
>
>
=
8
;
}
dst
-
>
push_back
(
0
|
(
(
59
+
count
)
<
<
2
)
)
;
*
dst
+
=
std
:
:
string
(
number
count
)
;
}
*
dst
+
=
literal
;
}
void
AppendCopy
(
std
:
:
string
*
dst
int
offset
int
length
)
{
while
(
length
>
0
)
{
int
to_copy
;
if
(
length
>
=
68
)
{
to_copy
=
64
;
}
else
if
(
length
>
64
)
{
to_copy
=
60
;
}
else
{
to_copy
=
length
;
}
length
-
=
to_copy
;
if
(
(
to_copy
>
=
4
)
&
&
(
to_copy
<
12
)
&
&
(
offset
<
2048
)
)
{
assert
(
to_copy
-
4
<
8
)
;
dst
-
>
push_back
(
1
|
(
(
to_copy
-
4
)
<
<
2
)
|
(
(
offset
>
>
8
)
<
<
5
)
)
;
dst
-
>
push_back
(
offset
&
0xff
)
;
}
else
if
(
offset
<
65536
)
{
dst
-
>
push_back
(
2
|
(
(
to_copy
-
1
)
<
<
2
)
)
;
dst
-
>
push_back
(
offset
&
0xff
)
;
dst
-
>
push_back
(
offset
>
>
8
)
;
}
else
{
dst
-
>
push_back
(
3
|
(
(
to_copy
-
1
)
<
<
2
)
)
;
dst
-
>
push_back
(
offset
&
0xff
)
;
dst
-
>
push_back
(
(
offset
>
>
8
)
&
0xff
)
;
dst
-
>
push_back
(
(
offset
>
>
16
)
&
0xff
)
;
dst
-
>
push_back
(
(
offset
>
>
24
)
&
0xff
)
;
}
}
}
TEST
(
Snappy
SimpleTests
)
{
Verify
(
"
"
)
;
Verify
(
"
a
"
)
;
Verify
(
"
ab
"
)
;
Verify
(
"
abc
"
)
;
Verify
(
"
aaaaaaa
"
+
std
:
:
string
(
16
'
b
'
)
+
std
:
:
string
(
"
aaaaa
"
)
+
"
abc
"
)
;
Verify
(
"
aaaaaaa
"
+
std
:
:
string
(
256
'
b
'
)
+
std
:
:
string
(
"
aaaaa
"
)
+
"
abc
"
)
;
Verify
(
"
aaaaaaa
"
+
std
:
:
string
(
2047
'
b
'
)
+
std
:
:
string
(
"
aaaaa
"
)
+
"
abc
"
)
;
Verify
(
"
aaaaaaa
"
+
std
:
:
string
(
65536
'
b
'
)
+
std
:
:
string
(
"
aaaaa
"
)
+
"
abc
"
)
;
Verify
(
"
abcaaaaaaa
"
+
std
:
:
string
(
65536
'
b
'
)
+
std
:
:
string
(
"
aaaaa
"
)
+
"
abc
"
)
;
}
TEST
(
Snappy
AppendSelfPatternExtensionEdgeCases
)
{
Verify
(
"
abcabcabcabcabcabcab
"
)
;
Verify
(
"
abcabcabcabcabcabcab0123456789ABCDEF
"
)
;
Verify
(
"
abcabcabcabcabcabcabcabcabcabcabcabc
"
)
;
Verify
(
"
abcabcabcabcabcabcabcabcabcabcabcabc0123456789ABCDEF
"
)
;
}
TEST
(
Snappy
AppendSelfPatternExtensionEdgeCasesExhaustive
)
{
std
:
:
mt19937
rng
;
std
:
:
uniform_int_distribution
<
int
>
uniform_byte
(
0
255
)
;
for
(
int
pattern_size
=
1
;
pattern_size
<
=
18
;
+
+
pattern_size
)
{
for
(
int
length
=
1
;
length
<
=
64
;
+
+
length
)
{
for
(
int
extra_bytes_after_pattern
:
{
0
1
15
16
128
}
)
{
const
int
size
=
pattern_size
+
length
+
extra_bytes_after_pattern
;
std
:
:
string
input
;
input
.
resize
(
size
)
;
for
(
int
i
=
0
;
i
<
pattern_size
;
+
+
i
)
{
input
[
i
]
=
'
a
'
+
i
;
}
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
input
[
pattern_size
+
i
]
=
input
[
i
]
;
}
for
(
int
i
=
0
;
i
<
extra_bytes_after_pattern
;
+
+
i
)
{
input
[
pattern_size
+
length
+
i
]
=
static_cast
<
char
>
(
uniform_byte
(
rng
)
)
;
}
Verify
(
input
)
;
}
}
}
}
TEST
(
Snappy
MaxBlowup
)
{
std
:
:
mt19937
rng
;
std
:
:
uniform_int_distribution
<
int
>
uniform_byte
(
0
255
)
;
std
:
:
string
input
;
for
(
int
i
=
0
;
i
<
80000
;
+
+
i
)
input
.
push_back
(
static_cast
<
char
>
(
uniform_byte
(
rng
)
)
)
;
for
(
int
i
=
0
;
i
<
80000
;
i
+
=
4
)
{
std
:
:
string
four_bytes
(
input
.
end
(
)
-
i
-
4
input
.
end
(
)
-
i
)
;
input
.
append
(
four_bytes
)
;
}
Verify
(
input
)
;
}
TEST
(
Snappy
RandomData
)
{
std
:
:
minstd_rand0
rng
(
snappy
:
:
GetFlag
(
FLAGS_test_random_seed
)
)
;
std
:
:
uniform_int_distribution
<
int
>
uniform_0_to_3
(
0
3
)
;
std
:
:
uniform_int_distribution
<
int
>
uniform_0_to_8
(
0
8
)
;
std
:
:
uniform_int_distribution
<
int
>
uniform_byte
(
0
255
)
;
std
:
:
uniform_int_distribution
<
size_t
>
uniform_4k
(
0
4095
)
;
std
:
:
uniform_int_distribution
<
size_t
>
uniform_64k
(
0
65535
)
;
std
:
:
bernoulli_distribution
one_in_ten
(
1
.
0
/
10
)
;
constexpr
int
num_ops
=
20000
;
for
(
int
i
=
0
;
i
<
num_ops
;
+
+
i
)
{
if
(
(
i
%
1000
)
=
=
0
)
{
VLOG
(
0
)
<
<
"
Random
op
"
<
<
i
<
<
"
of
"
<
<
num_ops
;
}
std
:
:
string
x
;
size_t
len
=
uniform_4k
(
rng
)
;
if
(
i
<
100
)
{
len
=
65536
+
uniform_64k
(
rng
)
;
}
while
(
x
.
size
(
)
<
len
)
{
int
run_len
=
1
;
if
(
one_in_ten
(
rng
)
)
{
int
skewed_bits
=
uniform_0_to_8
(
rng
)
;
std
:
:
uniform_int_distribution
<
int
>
skewed_low
(
0
(
1
<
<
skewed_bits
)
-
1
)
;
run_len
=
skewed_low
(
rng
)
;
}
char
c
=
static_cast
<
char
>
(
uniform_byte
(
rng
)
)
;
if
(
i
>
=
100
)
{
int
skewed_bits
=
uniform_0_to_3
(
rng
)
;
std
:
:
uniform_int_distribution
<
int
>
skewed_low
(
0
(
1
<
<
skewed_bits
)
-
1
)
;
c
=
static_cast
<
char
>
(
skewed_low
(
rng
)
)
;
}
while
(
run_len
-
-
>
0
&
&
x
.
size
(
)
<
len
)
{
x
.
push_back
(
c
)
;
}
}
Verify
(
x
)
;
}
}
TEST
(
Snappy
FourByteOffset
)
{
std
:
:
string
fragment1
=
"
012345689abcdefghijklmnopqrstuvwxyz
"
;
std
:
:
string
fragment2
=
"
some
other
string
"
;
const
int
n1
=
2
;
const
int
n2
=
100000
/
fragment2
.
size
(
)
;
const
size_t
length
=
n1
*
fragment1
.
size
(
)
+
n2
*
fragment2
.
size
(
)
;
std
:
:
string
compressed
;
Varint
:
:
Append32
(
&
compressed
length
)
;
AppendLiteral
(
&
compressed
fragment1
)
;
std
:
:
string
src
=
fragment1
;
for
(
int
i
=
0
;
i
<
n2
;
+
+
i
)
{
AppendLiteral
(
&
compressed
fragment2
)
;
src
+
=
fragment2
;
}
AppendCopy
(
&
compressed
src
.
size
(
)
fragment1
.
size
(
)
)
;
src
+
=
fragment1
;
CHECK_EQ
(
length
src
.
size
(
)
)
;
std
:
:
string
uncompressed
;
CHECK
(
snappy
:
:
IsValidCompressedBuffer
(
compressed
.
data
(
)
compressed
.
size
(
)
)
)
;
CHECK
(
snappy
:
:
Uncompress
(
compressed
.
data
(
)
compressed
.
size
(
)
&
uncompressed
)
)
;
CHECK_EQ
(
uncompressed
src
)
;
}
TEST
(
Snappy
IOVecEdgeCases
)
{
static
const
int
kLengths
[
]
=
{
2
1
4
8
128
}
;
struct
iovec
iov
[
ARRAYSIZE
(
kLengths
)
]
;
for
(
int
i
=
0
;
i
<
ARRAYSIZE
(
kLengths
)
;
+
+
i
)
{
iov
[
i
]
.
iov_base
=
new
char
[
kLengths
[
i
]
]
;
iov
[
i
]
.
iov_len
=
kLengths
[
i
]
;
}
std
:
:
string
compressed
;
Varint
:
:
Append32
(
&
compressed
22
)
;
AppendLiteral
(
&
compressed
"
abc123
"
)
;
AppendCopy
(
&
compressed
3
3
)
;
AppendCopy
(
&
compressed
6
9
)
;
AppendCopy
(
&
compressed
17
4
)
;
CHECK
(
snappy
:
:
RawUncompressToIOVec
(
compressed
.
data
(
)
compressed
.
size
(
)
iov
ARRAYSIZE
(
iov
)
)
)
;
CHECK_EQ
(
0
memcmp
(
iov
[
0
]
.
iov_base
"
ab
"
2
)
)
;
CHECK_EQ
(
0
memcmp
(
iov
[
1
]
.
iov_base
"
c
"
1
)
)
;
CHECK_EQ
(
0
memcmp
(
iov
[
2
]
.
iov_base
"
1231
"
4
)
)
;
CHECK_EQ
(
0
memcmp
(
iov
[
3
]
.
iov_base
"
23123123
"
8
)
)
;
CHECK_EQ
(
0
memcmp
(
iov
[
4
]
.
iov_base
"
123bc12
"
7
)
)
;
for
(
int
i
=
0
;
i
<
ARRAYSIZE
(
kLengths
)
;
+
+
i
)
{
delete
[
]
reinterpret_cast
<
char
*
>
(
iov
[
i
]
.
iov_base
)
;
}
}
TEST
(
Snappy
IOVecLiteralOverflow
)
{
static
const
int
kLengths
[
]
=
{
3
4
}
;
struct
iovec
iov
[
ARRAYSIZE
(
kLengths
)
]
;
for
(
int
i
=
0
;
i
<
ARRAYSIZE
(
kLengths
)
;
+
+
i
)
{
iov
[
i
]
.
iov_base
=
new
char
[
kLengths
[
i
]
]
;
iov
[
i
]
.
iov_len
=
kLengths
[
i
]
;
}
std
:
:
string
compressed
;
Varint
:
:
Append32
(
&
compressed
8
)
;
AppendLiteral
(
&
compressed
"
12345678
"
)
;
CHECK
(
!
snappy
:
:
RawUncompressToIOVec
(
compressed
.
data
(
)
compressed
.
size
(
)
iov
ARRAYSIZE
(
iov
)
)
)
;
for
(
int
i
=
0
;
i
<
ARRAYSIZE
(
kLengths
)
;
+
+
i
)
{
delete
[
]
reinterpret_cast
<
char
*
>
(
iov
[
i
]
.
iov_base
)
;
}
}
TEST
(
Snappy
IOVecCopyOverflow
)
{
static
const
int
kLengths
[
]
=
{
3
4
}
;
struct
iovec
iov
[
ARRAYSIZE
(
kLengths
)
]
;
for
(
int
i
=
0
;
i
<
ARRAYSIZE
(
kLengths
)
;
+
+
i
)
{
iov
[
i
]
.
iov_base
=
new
char
[
kLengths
[
i
]
]
;
iov
[
i
]
.
iov_len
=
kLengths
[
i
]
;
}
std
:
:
string
compressed
;
Varint
:
:
Append32
(
&
compressed
8
)
;
AppendLiteral
(
&
compressed
"
123
"
)
;
AppendCopy
(
&
compressed
3
5
)
;
CHECK
(
!
snappy
:
:
RawUncompressToIOVec
(
compressed
.
data
(
)
compressed
.
size
(
)
iov
ARRAYSIZE
(
iov
)
)
)
;
for
(
int
i
=
0
;
i
<
ARRAYSIZE
(
kLengths
)
;
+
+
i
)
{
delete
[
]
reinterpret_cast
<
char
*
>
(
iov
[
i
]
.
iov_base
)
;
}
}
bool
CheckUncompressedLength
(
const
std
:
:
string
&
compressed
size_t
*
ulength
)
{
const
bool
result1
=
snappy
:
:
GetUncompressedLength
(
compressed
.
data
(
)
compressed
.
size
(
)
ulength
)
;
snappy
:
:
ByteArraySource
source
(
compressed
.
data
(
)
compressed
.
size
(
)
)
;
uint32_t
length
;
const
bool
result2
=
snappy
:
:
GetUncompressedLength
(
&
source
&
length
)
;
CHECK_EQ
(
result1
result2
)
;
return
result1
;
}
TEST
(
SnappyCorruption
TruncatedVarint
)
{
std
:
:
string
compressed
uncompressed
;
size_t
ulength
;
compressed
.
push_back
(
'
\
xf0
'
)
;
CHECK
(
!
CheckUncompressedLength
(
compressed
&
ulength
)
)
;
CHECK
(
!
snappy
:
:
IsValidCompressedBuffer
(
compressed
.
data
(
)
compressed
.
size
(
)
)
)
;
CHECK
(
!
snappy
:
:
Uncompress
(
compressed
.
data
(
)
compressed
.
size
(
)
&
uncompressed
)
)
;
}
TEST
(
SnappyCorruption
UnterminatedVarint
)
{
std
:
:
string
compressed
uncompressed
;
size_t
ulength
;
compressed
.
push_back
(
'
\
x80
'
)
;
compressed
.
push_back
(
'
\
x80
'
)
;
compressed
.
push_back
(
'
\
x80
'
)
;
compressed
.
push_back
(
'
\
x80
'
)
;
compressed
.
push_back
(
'
\
x80
'
)
;
compressed
.
push_back
(
10
)
;
CHECK
(
!
CheckUncompressedLength
(
compressed
&
ulength
)
)
;
CHECK
(
!
snappy
:
:
IsValidCompressedBuffer
(
compressed
.
data
(
)
compressed
.
size
(
)
)
)
;
CHECK
(
!
snappy
:
:
Uncompress
(
compressed
.
data
(
)
compressed
.
size
(
)
&
uncompressed
)
)
;
}
TEST
(
SnappyCorruption
OverflowingVarint
)
{
std
:
:
string
compressed
uncompressed
;
size_t
ulength
;
compressed
.
push_back
(
'
\
xfb
'
)
;
compressed
.
push_back
(
'
\
xff
'
)
;
compressed
.
push_back
(
'
\
xff
'
)
;
compressed
.
push_back
(
'
\
xff
'
)
;
compressed
.
push_back
(
'
\
x7f
'
)
;
CHECK
(
!
CheckUncompressedLength
(
compressed
&
ulength
)
)
;
CHECK
(
!
snappy
:
:
IsValidCompressedBuffer
(
compressed
.
data
(
)
compressed
.
size
(
)
)
)
;
CHECK
(
!
snappy
:
:
Uncompress
(
compressed
.
data
(
)
compressed
.
size
(
)
&
uncompressed
)
)
;
}
TEST
(
Snappy
ReadPastEndOfBuffer
)
{
std
:
:
string
compressed
;
Varint
:
:
Append32
(
&
compressed
1
)
;
AppendLiteral
(
&
compressed
"
x
"
)
;
std
:
:
string
uncompressed
;
DataEndingAtUnreadablePage
c
(
compressed
)
;
CHECK
(
snappy
:
:
Uncompress
(
c
.
data
(
)
c
.
size
(
)
&
uncompressed
)
)
;
CHECK_EQ
(
uncompressed
std
:
:
string
(
"
x
"
)
)
;
}
TEST
(
Snappy
ZeroOffsetCopy
)
{
const
char
*
compressed
=
"
\
x40
\
x12
\
x00
\
x00
"
;
char
uncompressed
[
100
]
;
EXPECT_FALSE
(
snappy
:
:
RawUncompress
(
compressed
4
uncompressed
)
)
;
}
TEST
(
Snappy
ZeroOffsetCopyValidation
)
{
const
char
*
compressed
=
"
\
x05
\
x12
\
x00
\
x00
"
;
EXPECT_FALSE
(
snappy
:
:
IsValidCompressedBuffer
(
compressed
4
)
)
;
}
int
TestFindMatchLength
(
const
char
*
s1
const
char
*
s2
unsigned
length
)
{
uint64_t
data
;
std
:
:
pair
<
size_t
bool
>
p
=
snappy
:
:
internal
:
:
FindMatchLength
(
s1
s2
s2
+
length
&
data
)
;
CHECK_EQ
(
p
.
first
<
8
p
.
second
)
;
return
p
.
first
;
}
TEST
(
Snappy
FindMatchLength
)
{
EXPECT_EQ
(
6
TestFindMatchLength
(
"
012345
"
"
012345
"
6
)
)
;
EXPECT_EQ
(
11
TestFindMatchLength
(
"
01234567abc
"
"
01234567abc
"
11
)
)
;
EXPECT_EQ
(
9
TestFindMatchLength
(
"
01234567abc
"
"
01234567axc
"
9
)
)
;
EXPECT_EQ
(
11
TestFindMatchLength
(
"
01234567abc
!
"
"
01234567abc
!
"
11
)
)
;
EXPECT_EQ
(
11
TestFindMatchLength
(
"
01234567abc
!
"
"
01234567abc
?
"
11
)
)
;
EXPECT_EQ
(
0
TestFindMatchLength
(
"
01234567xxxxxxxx
"
"
?
1234567xxxxxxxx
"
16
)
)
;
EXPECT_EQ
(
1
TestFindMatchLength
(
"
01234567xxxxxxxx
"
"
0
?
234567xxxxxxxx
"
16
)
)
;
EXPECT_EQ
(
4
TestFindMatchLength
(
"
01234567xxxxxxxx
"
"
01237654xxxxxxxx
"
16
)
)
;
EXPECT_EQ
(
7
TestFindMatchLength
(
"
01234567xxxxxxxx
"
"
0123456
?
xxxxxxxx
"
16
)
)
;
EXPECT_EQ
(
8
TestFindMatchLength
(
"
abcdefgh01234567xxxxxxxx
"
"
abcdefgh
?
1234567xxxxxxxx
"
24
)
)
;
EXPECT_EQ
(
9
TestFindMatchLength
(
"
abcdefgh01234567xxxxxxxx
"
"
abcdefgh0
?
234567xxxxxxxx
"
24
)
)
;
EXPECT_EQ
(
12
TestFindMatchLength
(
"
abcdefgh01234567xxxxxxxx
"
"
abcdefgh01237654xxxxxxxx
"
24
)
)
;
EXPECT_EQ
(
15
TestFindMatchLength
(
"
abcdefgh01234567xxxxxxxx
"
"
abcdefgh0123456
?
xxxxxxxx
"
24
)
)
;
EXPECT_EQ
(
0
TestFindMatchLength
(
"
01234567
"
"
?
1234567
"
8
)
)
;
EXPECT_EQ
(
1
TestFindMatchLength
(
"
01234567
"
"
0
?
234567
"
8
)
)
;
EXPECT_EQ
(
2
TestFindMatchLength
(
"
01234567
"
"
01
?
34567
"
8
)
)
;
EXPECT_EQ
(
3
TestFindMatchLength
(
"
01234567
"
"
012
?
4567
"
8
)
)
;
EXPECT_EQ
(
4
TestFindMatchLength
(
"
01234567
"
"
0123
?
567
"
8
)
)
;
EXPECT_EQ
(
5
TestFindMatchLength
(
"
01234567
"
"
01234
?
67
"
8
)
)
;
EXPECT_EQ
(
6
TestFindMatchLength
(
"
01234567
"
"
012345
?
7
"
8
)
)
;
EXPECT_EQ
(
7
TestFindMatchLength
(
"
01234567
"
"
0123456
?
"
8
)
)
;
EXPECT_EQ
(
7
TestFindMatchLength
(
"
01234567
"
"
0123456
?
"
7
)
)
;
EXPECT_EQ
(
7
TestFindMatchLength
(
"
01234567
!
"
"
0123456
?
?
"
7
)
)
;
EXPECT_EQ
(
10
TestFindMatchLength
(
"
xxxxxxabcd
"
"
xxxxxxabcd
"
10
)
)
;
EXPECT_EQ
(
10
TestFindMatchLength
(
"
xxxxxxabcd
?
"
"
xxxxxxabcd
?
"
10
)
)
;
EXPECT_EQ
(
13
TestFindMatchLength
(
"
xxxxxxabcdef
"
"
xxxxxxabcdef
"
13
)
)
;
EXPECT_EQ
(
12
TestFindMatchLength
(
"
xxxxxx0123abc
!
"
"
xxxxxx0123abc
!
"
12
)
)
;
EXPECT_EQ
(
12
TestFindMatchLength
(
"
xxxxxx0123abc
!
"
"
xxxxxx0123abc
?
"
12
)
)
;
EXPECT_EQ
(
11
TestFindMatchLength
(
"
xxxxxx0123abc
"
"
xxxxxx0123axc
"
13
)
)
;
EXPECT_EQ
(
6
TestFindMatchLength
(
"
xxxxxx0123xxxxxxxx
"
"
xxxxxx
?
123xxxxxxxx
"
18
)
)
;
EXPECT_EQ
(
7
TestFindMatchLength
(
"
xxxxxx0123xxxxxxxx
"
"
xxxxxx0
?
23xxxxxxxx
"
18
)
)
;
EXPECT_EQ
(
8
TestFindMatchLength
(
"
xxxxxx0123xxxxxxxx
"
"
xxxxxx0132xxxxxxxx
"
18
)
)
;
EXPECT_EQ
(
9
TestFindMatchLength
(
"
xxxxxx0123xxxxxxxx
"
"
xxxxxx012
?
xxxxxxxx
"
18
)
)
;
EXPECT_EQ
(
6
TestFindMatchLength
(
"
xxxxxx0123
"
"
xxxxxx
?
123
"
10
)
)
;
EXPECT_EQ
(
7
TestFindMatchLength
(
"
xxxxxx0123
"
"
xxxxxx0
?
23
"
10
)
)
;
EXPECT_EQ
(
8
TestFindMatchLength
(
"
xxxxxx0123
"
"
xxxxxx0132
"
10
)
)
;
EXPECT_EQ
(
9
TestFindMatchLength
(
"
xxxxxx0123
"
"
xxxxxx012
?
"
10
)
)
;
EXPECT_EQ
(
10
TestFindMatchLength
(
"
xxxxxxabcd0123xx
"
"
xxxxxxabcd
?
123xx
"
16
)
)
;
EXPECT_EQ
(
11
TestFindMatchLength
(
"
xxxxxxabcd0123xx
"
"
xxxxxxabcd0
?
23xx
"
16
)
)
;
EXPECT_EQ
(
12
TestFindMatchLength
(
"
xxxxxxabcd0123xx
"
"
xxxxxxabcd0132xx
"
16
)
)
;
EXPECT_EQ
(
13
TestFindMatchLength
(
"
xxxxxxabcd0123xx
"
"
xxxxxxabcd012
?
xx
"
16
)
)
;
EXPECT_EQ
(
10
TestFindMatchLength
(
"
xxxxxxabcd0123
"
"
xxxxxxabcd
?
123
"
14
)
)
;
EXPECT_EQ
(
11
TestFindMatchLength
(
"
xxxxxxabcd0123
"
"
xxxxxxabcd0
?
23
"
14
)
)
;
EXPECT_EQ
(
12
TestFindMatchLength
(
"
xxxxxxabcd0123
"
"
xxxxxxabcd0132
"
14
)
)
;
EXPECT_EQ
(
13
TestFindMatchLength
(
"
xxxxxxabcd0123
"
"
xxxxxxabcd012
?
"
14
)
)
;
}
TEST
(
Snappy
FindMatchLengthRandom
)
{
constexpr
int
kNumTrials
=
10000
;
constexpr
int
kTypicalLength
=
10
;
std
:
:
minstd_rand0
rng
(
snappy
:
:
GetFlag
(
FLAGS_test_random_seed
)
)
;
std
:
:
uniform_int_distribution
<
int
>
uniform_byte
(
0
255
)
;
std
:
:
bernoulli_distribution
one_in_two
(
1
.
0
/
2
)
;
std
:
:
bernoulli_distribution
one_in_typical_length
(
1
.
0
/
kTypicalLength
)
;
for
(
int
i
=
0
;
i
<
kNumTrials
;
+
+
i
)
{
std
:
:
string
s
t
;
char
a
=
static_cast
<
char
>
(
uniform_byte
(
rng
)
)
;
char
b
=
static_cast
<
char
>
(
uniform_byte
(
rng
)
)
;
while
(
!
one_in_typical_length
(
rng
)
)
{
s
.
push_back
(
one_in_two
(
rng
)
?
a
:
b
)
;
t
.
push_back
(
one_in_two
(
rng
)
?
a
:
b
)
;
}
DataEndingAtUnreadablePage
u
(
s
)
;
DataEndingAtUnreadablePage
v
(
t
)
;
size_t
matched
=
TestFindMatchLength
(
u
.
data
(
)
v
.
data
(
)
t
.
size
(
)
)
;
if
(
matched
=
=
t
.
size
(
)
)
{
EXPECT_EQ
(
s
t
)
;
}
else
{
EXPECT_NE
(
s
[
matched
]
t
[
matched
]
)
;
for
(
size_t
j
=
0
;
j
<
matched
;
+
+
j
)
{
EXPECT_EQ
(
s
[
j
]
t
[
j
]
)
;
}
}
}
}
uint16_t
MakeEntry
(
unsigned
int
extra
unsigned
int
len
unsigned
int
copy_offset
)
{
assert
(
extra
=
=
(
extra
&
0x7
)
)
;
assert
(
copy_offset
=
=
(
copy_offset
&
0x7
)
)
;
assert
(
len
=
=
(
len
&
0x7f
)
)
;
return
len
|
(
copy_offset
<
<
8
)
|
(
extra
<
<
11
)
;
}
TEST
(
Snappy
VerifyCharTable
)
{
using
snappy
:
:
internal
:
:
LITERAL
;
using
snappy
:
:
internal
:
:
COPY_1_BYTE_OFFSET
;
using
snappy
:
:
internal
:
:
COPY_2_BYTE_OFFSET
;
using
snappy
:
:
internal
:
:
COPY_4_BYTE_OFFSET
;
using
snappy
:
:
internal
:
:
char_table
;
uint16_t
dst
[
256
]
;
int
assigned
=
0
;
for
(
int
i
=
0
;
i
<
256
;
+
+
i
)
{
dst
[
i
]
=
0xffff
;
}
for
(
uint8_t
len
=
1
;
len
<
=
60
;
+
+
len
)
{
dst
[
LITERAL
|
(
(
len
-
1
)
<
<
2
)
]
=
MakeEntry
(
0
len
0
)
;
assigned
+
+
;
}
for
(
uint8_t
extra_bytes
=
1
;
extra_bytes
<
=
4
;
+
+
extra_bytes
)
{
dst
[
LITERAL
|
(
(
extra_bytes
+
59
)
<
<
2
)
]
=
MakeEntry
(
extra_bytes
1
0
)
;
assigned
+
+
;
}
for
(
uint8_t
len
=
4
;
len
<
12
;
+
+
len
)
{
for
(
uint16_t
offset
=
0
;
offset
<
2048
;
offset
+
=
256
)
{
uint8_t
offset_high
=
static_cast
<
uint8_t
>
(
offset
>
>
8
)
;
dst
[
COPY_1_BYTE_OFFSET
|
(
(
len
-
4
)
<
<
2
)
|
(
offset_high
<
<
5
)
]
=
MakeEntry
(
1
len
offset_high
)
;
assigned
+
+
;
}
}
for
(
uint8_t
len
=
1
;
len
<
=
64
;
+
+
len
)
{
dst
[
COPY_2_BYTE_OFFSET
|
(
(
len
-
1
)
<
<
2
)
]
=
MakeEntry
(
2
len
0
)
;
assigned
+
+
;
}
for
(
uint8_t
len
=
1
;
len
<
=
64
;
+
+
len
)
{
dst
[
COPY_4_BYTE_OFFSET
|
(
(
len
-
1
)
<
<
2
)
]
=
MakeEntry
(
4
len
0
)
;
assigned
+
+
;
}
EXPECT_EQ
(
256
assigned
)
<
<
"
Assigned
only
"
<
<
assigned
<
<
"
of
256
"
;
for
(
int
i
=
0
;
i
<
256
;
+
+
i
)
{
EXPECT_NE
(
0xffff
dst
[
i
]
)
<
<
"
Did
not
assign
byte
"
<
<
i
;
}
if
(
snappy
:
:
GetFlag
(
FLAGS_snappy_dump_decompression_table
)
)
{
std
:
:
printf
(
"
static
const
uint16_t
char_table
[
256
]
=
{
\
n
"
)
;
for
(
int
i
=
0
;
i
<
256
;
+
+
i
)
{
std
:
:
printf
(
"
0x
%
04x
%
s
"
dst
[
i
]
(
(
i
=
=
255
)
?
"
\
n
"
:
(
(
(
i
%
8
)
=
=
7
)
?
"
\
n
"
:
"
"
)
)
)
;
}
std
:
:
printf
(
"
}
;
\
n
"
)
;
}
for
(
int
i
=
0
;
i
<
256
;
+
+
i
)
{
EXPECT_EQ
(
dst
[
i
]
char_table
[
i
]
)
<
<
"
Mismatch
in
byte
"
<
<
i
;
}
}
TEST
(
Snappy
TestBenchmarkFiles
)
{
for
(
int
i
=
0
;
i
<
ARRAYSIZE
(
kTestDataFiles
)
;
+
+
i
)
{
Verify
(
ReadTestDataFile
(
kTestDataFiles
[
i
]
.
filename
kTestDataFiles
[
i
]
.
size_limit
)
)
;
}
}
}
}
