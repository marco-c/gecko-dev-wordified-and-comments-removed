import
sys
sys
.
path
.
insert
(
0
"
.
.
/
.
.
"
)
import
ply
.
lex
as
lex
reserved
=
(
    
'
AUTO
'
'
BREAK
'
'
CASE
'
'
CHAR
'
'
CONST
'
'
CONTINUE
'
'
DEFAULT
'
'
DO
'
'
DOUBLE
'
    
'
ELSE
'
'
ENUM
'
'
EXTERN
'
'
FLOAT
'
'
FOR
'
'
GOTO
'
'
IF
'
'
INT
'
'
LONG
'
'
REGISTER
'
    
'
RETURN
'
'
SHORT
'
'
SIGNED
'
'
SIZEOF
'
'
STATIC
'
'
STRUCT
'
'
SWITCH
'
'
TYPEDEF
'
    
'
UNION
'
'
UNSIGNED
'
'
VOID
'
'
VOLATILE
'
'
WHILE
'
)
tokens
=
reserved
+
(
    
'
ID
'
'
TYPEID
'
'
ICONST
'
'
FCONST
'
'
SCONST
'
'
CCONST
'
    
'
PLUS
'
'
MINUS
'
'
TIMES
'
'
DIVIDE
'
'
MOD
'
    
'
OR
'
'
AND
'
'
NOT
'
'
XOR
'
'
LSHIFT
'
'
RSHIFT
'
    
'
LOR
'
'
LAND
'
'
LNOT
'
    
'
LT
'
'
LE
'
'
GT
'
'
GE
'
'
EQ
'
'
NE
'
    
'
EQUALS
'
'
TIMESEQUAL
'
'
DIVEQUAL
'
'
MODEQUAL
'
'
PLUSEQUAL
'
'
MINUSEQUAL
'
    
'
LSHIFTEQUAL
'
'
RSHIFTEQUAL
'
'
ANDEQUAL
'
'
XOREQUAL
'
'
OREQUAL
'
    
'
PLUSPLUS
'
'
MINUSMINUS
'
    
'
ARROW
'
    
'
CONDOP
'
    
'
LPAREN
'
'
RPAREN
'
    
'
LBRACKET
'
'
RBRACKET
'
    
'
LBRACE
'
'
RBRACE
'
    
'
COMMA
'
'
PERIOD
'
'
SEMI
'
'
COLON
'
    
'
ELLIPSIS
'
)
t_ignore
=
'
\
t
\
x0c
'
def
t_NEWLINE
(
t
)
:
    
r
'
\
n
+
'
    
t
.
lexer
.
lineno
+
=
t
.
value
.
count
(
"
\
n
"
)
t_PLUS
=
r
'
\
+
'
t_MINUS
=
r
'
-
'
t_TIMES
=
r
'
\
*
'
t_DIVIDE
=
r
'
/
'
t_MOD
=
r
'
%
'
t_OR
=
r
'
\
|
'
t_AND
=
r
'
&
'
t_NOT
=
r
'
~
'
t_XOR
=
r
'
\
^
'
t_LSHIFT
=
r
'
<
<
'
t_RSHIFT
=
r
'
>
>
'
t_LOR
=
r
'
\
|
\
|
'
t_LAND
=
r
'
&
&
'
t_LNOT
=
r
'
!
'
t_LT
=
r
'
<
'
t_GT
=
r
'
>
'
t_LE
=
r
'
<
=
'
t_GE
=
r
'
>
=
'
t_EQ
=
r
'
=
=
'
t_NE
=
r
'
!
=
'
t_EQUALS
=
r
'
=
'
t_TIMESEQUAL
=
r
'
\
*
=
'
t_DIVEQUAL
=
r
'
/
=
'
t_MODEQUAL
=
r
'
%
=
'
t_PLUSEQUAL
=
r
'
\
+
=
'
t_MINUSEQUAL
=
r
'
-
=
'
t_LSHIFTEQUAL
=
r
'
<
<
=
'
t_RSHIFTEQUAL
=
r
'
>
>
=
'
t_ANDEQUAL
=
r
'
&
=
'
t_OREQUAL
=
r
'
\
|
=
'
t_XOREQUAL
=
r
'
\
^
=
'
t_PLUSPLUS
=
r
'
\
+
\
+
'
t_MINUSMINUS
=
r
'
-
-
'
t_ARROW
=
r
'
-
>
'
t_CONDOP
=
r
'
\
?
'
t_LPAREN
=
r
'
\
(
'
t_RPAREN
=
r
'
\
)
'
t_LBRACKET
=
r
'
\
[
'
t_RBRACKET
=
r
'
\
]
'
t_LBRACE
=
r
'
\
{
'
t_RBRACE
=
r
'
\
}
'
t_COMMA
=
r
'
'
t_PERIOD
=
r
'
\
.
'
t_SEMI
=
r
'
;
'
t_COLON
=
r
'
:
'
t_ELLIPSIS
=
r
'
\
.
\
.
\
.
'
reserved_map
=
{
}
for
r
in
reserved
:
    
reserved_map
[
r
.
lower
(
)
]
=
r
def
t_ID
(
t
)
:
    
r
'
[
A
-
Za
-
z_
]
[
\
w_
]
*
'
    
t
.
type
=
reserved_map
.
get
(
t
.
value
"
ID
"
)
    
return
t
t_ICONST
=
r
'
\
d
+
(
[
uU
]
|
[
lL
]
|
[
uU
]
[
lL
]
|
[
lL
]
[
uU
]
)
?
'
t_FCONST
=
r
'
(
(
\
d
+
)
(
\
.
\
d
+
)
(
e
(
\
+
|
-
)
?
(
\
d
+
)
)
?
|
(
\
d
+
)
e
(
\
+
|
-
)
?
(
\
d
+
)
)
(
[
lL
]
|
[
fF
]
)
?
'
t_SCONST
=
r
'
\
"
(
[
^
\
\
\
n
]
|
(
\
\
.
)
)
*
?
\
"
'
t_CCONST
=
r
'
(
L
)
?
\
'
(
[
^
\
\
\
n
]
|
(
\
\
.
)
)
*
?
\
'
'
def
t_comment
(
t
)
:
    
r
'
/
\
*
(
.
|
\
n
)
*
?
\
*
/
'
    
t
.
lexer
.
lineno
+
=
t
.
value
.
count
(
'
\
n
'
)
def
t_preprocessor
(
t
)
:
    
r
'
\
#
(
.
)
*
?
\
n
'
    
t
.
lexer
.
lineno
+
=
1
def
t_error
(
t
)
:
    
print
(
"
Illegal
character
%
s
"
%
repr
(
t
.
value
[
0
]
)
)
    
t
.
lexer
.
skip
(
1
)
lexer
=
lex
.
lex
(
)
if
__name__
=
=
"
__main__
"
:
    
lex
.
runmain
(
lexer
)
