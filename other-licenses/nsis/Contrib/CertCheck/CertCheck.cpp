#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
windows
.
h
>
#
include
<
softpub
.
h
>
#
include
<
wintrust
.
h
>
#
pragma
comment
(
lib
"
wintrust
.
lib
"
)
#
pragma
comment
(
lib
"
crypt32
.
lib
"
)
#
ifndef
UNICODE
#
error
"
This
file
only
supports
building
in
Unicode
mode
"
#
endif
static
const
int
ENCODING
=
X509_ASN_ENCODING
|
PKCS_7_ASN_ENCODING
;
enum
NSPIM
{
NSPIM_UNLOAD
NSPIM_GUIUNLOAD
}
;
typedef
UINT_PTR
(
*
NSISPLUGINCALLBACK
)
(
enum
NSPIM
)
;
struct
extra_parameters
{
void
*
exec_flags
;
int
(
__stdcall
*
ExecuteCodeSegment
)
(
int
HWND
)
;
void
(
__stdcall
*
validate_filename
)
(
TCHAR
*
)
;
int
(
__stdcall
*
RegisterPluginCallback
)
(
HMODULE
NSISPLUGINCALLBACK
)
;
}
;
typedef
struct
_stack_t
{
struct
_stack_t
*
next
;
TCHAR
text
[
MAX_PATH
]
;
}
stack_t
;
int
popstring
(
stack_t
*
*
stacktop
LPTSTR
str
int
len
)
;
void
pushstring
(
stack_t
*
*
stacktop
LPCTSTR
str
int
len
)
;
struct
CertificateCheckInfo
{
wchar_t
filePath
[
MAX_PATH
]
;
wchar_t
name
[
MAX_PATH
]
;
wchar_t
issuer
[
MAX_PATH
]
;
}
;
static
HINSTANCE
gHInst
;
static
HANDLE
gCheckThread
;
static
HANDLE
gCheckEvent
;
static
bool
gCheckTrustPassed
;
static
bool
gCheckAttributesPassed
;
UINT_PTR
__cdecl
NSISPluginCallback
(
NSPIM
event
)
{
if
(
event
=
=
NSPIM_UNLOAD
)
{
if
(
gCheckThread
!
=
NULL
&
&
WaitForSingleObject
(
gCheckThread
0
)
!
=
WAIT_OBJECT_0
)
{
TerminateThread
(
gCheckThread
ERROR_OPERATION_ABORTED
)
;
}
CloseHandle
(
gCheckThread
)
;
gCheckThread
=
NULL
;
CloseHandle
(
gCheckEvent
)
;
gCheckEvent
=
NULL
;
}
return
NULL
;
}
BOOL
DoCertificateAttributesMatch
(
PCCERT_CONTEXT
certContext
CertificateCheckInfo
*
infoToMatch
)
{
DWORD
dwData
;
LPTSTR
szName
=
NULL
;
dwData
=
CertGetNameString
(
certContext
CERT_NAME_SIMPLE_DISPLAY_TYPE
CERT_NAME_ISSUER_FLAG
NULL
NULL
0
)
;
if
(
!
dwData
)
{
return
FALSE
;
}
szName
=
(
LPTSTR
)
LocalAlloc
(
LPTR
dwData
*
sizeof
(
WCHAR
)
)
;
if
(
!
szName
)
{
return
FALSE
;
}
if
(
!
CertGetNameString
(
certContext
CERT_NAME_SIMPLE_DISPLAY_TYPE
CERT_NAME_ISSUER_FLAG
NULL
szName
dwData
)
)
{
LocalFree
(
szName
)
;
return
FALSE
;
}
if
(
!
infoToMatch
-
>
issuer
|
|
wcscmp
(
szName
infoToMatch
-
>
issuer
)
)
{
LocalFree
(
szName
)
;
return
FALSE
;
}
LocalFree
(
szName
)
;
szName
=
NULL
;
dwData
=
CertGetNameString
(
certContext
CERT_NAME_SIMPLE_DISPLAY_TYPE
0
NULL
NULL
0
)
;
if
(
!
dwData
)
{
return
FALSE
;
}
szName
=
(
LPTSTR
)
LocalAlloc
(
LPTR
dwData
*
sizeof
(
WCHAR
)
)
;
if
(
!
szName
)
{
return
FALSE
;
}
if
(
!
(
CertGetNameString
(
certContext
CERT_NAME_SIMPLE_DISPLAY_TYPE
0
NULL
szName
dwData
)
)
)
{
LocalFree
(
szName
)
;
return
FALSE
;
}
if
(
!
infoToMatch
-
>
name
|
|
wcscmp
(
szName
infoToMatch
-
>
name
)
)
{
LocalFree
(
szName
)
;
return
FALSE
;
}
LocalFree
(
szName
)
;
return
TRUE
;
}
DWORD
CheckCertificateInfoForPEFile
(
CertificateCheckInfo
*
info
)
{
HCERTSTORE
certStore
=
NULL
;
HCRYPTMSG
cryptMsg
=
NULL
;
PCCERT_CONTEXT
certContext
=
NULL
;
PCMSG_SIGNER_INFO
signerInfo
=
NULL
;
DWORD
lastError
=
ERROR_SUCCESS
;
DWORD
encoding
contentType
formatType
;
BOOL
result
=
CryptQueryObject
(
CERT_QUERY_OBJECT_FILE
info
-
>
filePath
CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED
CERT_QUERY_CONTENT_FLAG_ALL
0
&
encoding
&
contentType
&
formatType
&
certStore
&
cryptMsg
NULL
)
;
if
(
!
result
)
{
lastError
=
GetLastError
(
)
;
goto
cleanup
;
}
DWORD
signerInfoSize
;
result
=
CryptMsgGetParam
(
cryptMsg
CMSG_SIGNER_INFO_PARAM
0
NULL
&
signerInfoSize
)
;
if
(
!
result
)
{
lastError
=
GetLastError
(
)
;
goto
cleanup
;
}
signerInfo
=
(
PCMSG_SIGNER_INFO
)
LocalAlloc
(
LPTR
signerInfoSize
)
;
if
(
!
signerInfo
)
{
lastError
=
GetLastError
(
)
;
goto
cleanup
;
}
result
=
CryptMsgGetParam
(
cryptMsg
CMSG_SIGNER_INFO_PARAM
0
(
PVOID
)
signerInfo
&
signerInfoSize
)
;
if
(
!
result
)
{
lastError
=
GetLastError
(
)
;
goto
cleanup
;
}
CERT_INFO
certInfo
;
certInfo
.
Issuer
=
signerInfo
-
>
Issuer
;
certInfo
.
SerialNumber
=
signerInfo
-
>
SerialNumber
;
certContext
=
CertFindCertificateInStore
(
certStore
ENCODING
0
CERT_FIND_SUBJECT_CERT
(
PVOID
)
&
certInfo
NULL
)
;
if
(
!
certContext
)
{
lastError
=
GetLastError
(
)
;
goto
cleanup
;
}
if
(
!
DoCertificateAttributesMatch
(
certContext
info
)
)
{
lastError
=
ERROR_NOT_FOUND
;
goto
cleanup
;
}
cleanup
:
if
(
signerInfo
)
{
LocalFree
(
signerInfo
)
;
}
if
(
certContext
)
{
CertFreeCertificateContext
(
certContext
)
;
}
if
(
certStore
)
{
CertCloseStore
(
certStore
0
)
;
}
if
(
cryptMsg
)
{
CryptMsgClose
(
cryptMsg
)
;
}
return
lastError
;
}
DWORD
VerifyCertificateTrustForFile
(
LPCWSTR
filePath
)
{
WINTRUST_FILE_INFO
fileToCheck
;
ZeroMemory
(
&
fileToCheck
sizeof
(
fileToCheck
)
)
;
fileToCheck
.
cbStruct
=
sizeof
(
WINTRUST_FILE_INFO
)
;
fileToCheck
.
pcwszFilePath
=
filePath
;
WINTRUST_DATA
trustData
;
SecureZeroMemory
(
&
trustData
sizeof
(
trustData
)
)
;
trustData
.
cbStruct
=
sizeof
(
trustData
)
;
trustData
.
dwUIChoice
=
WTD_UI_NONE
;
trustData
.
dwUnionChoice
=
WTD_CHOICE_FILE
;
trustData
.
pFile
=
&
fileToCheck
;
GUID
policyGUID
=
WINTRUST_ACTION_GENERIC_VERIFY_V2
;
LONG
ret
=
WinVerifyTrust
(
NULL
&
policyGUID
&
trustData
)
;
return
ret
;
}
DWORD
WINAPI
VerifyCertThreadProc
(
void
*
info
)
{
CertificateCheckInfo
*
certInfo
=
(
CertificateCheckInfo
*
)
info
;
if
(
VerifyCertificateTrustForFile
(
certInfo
-
>
filePath
)
=
=
ERROR_SUCCESS
)
{
gCheckTrustPassed
=
true
;
}
if
(
CheckCertificateInfoForPEFile
(
certInfo
)
=
=
ERROR_SUCCESS
)
{
gCheckAttributesPassed
=
true
;
}
LocalFree
(
info
)
;
SetEvent
(
gCheckEvent
)
;
return
0
;
}
extern
"
C
"
void
__declspec
(
dllexport
)
CheckPETrustAndInfoAsync
(
HWND
int
TCHAR
*
stack_t
*
*
stacktop
extra_parameters
*
pX
)
{
pX
-
>
RegisterPluginCallback
(
gHInst
NSISPluginCallback
)
;
gCheckTrustPassed
=
false
;
gCheckAttributesPassed
=
false
;
gCheckThread
=
nullptr
;
CertificateCheckInfo
*
certInfo
=
(
CertificateCheckInfo
*
)
LocalAlloc
(
0
sizeof
(
CertificateCheckInfo
)
)
;
if
(
certInfo
)
{
popstring
(
stacktop
certInfo
-
>
filePath
MAX_PATH
)
;
popstring
(
stacktop
certInfo
-
>
name
MAX_PATH
)
;
popstring
(
stacktop
certInfo
-
>
issuer
MAX_PATH
)
;
gCheckThread
=
CreateThread
(
nullptr
0
VerifyCertThreadProc
(
void
*
)
certInfo
0
nullptr
)
;
}
if
(
!
gCheckThread
)
{
LocalFree
(
certInfo
)
;
SetEvent
(
gCheckEvent
)
;
}
}
extern
"
C
"
void
__declspec
(
dllexport
)
GetStatus
(
HWND
int
TCHAR
*
stack_t
*
*
stacktop
void
*
)
{
if
(
WaitForSingleObject
(
gCheckEvent
0
)
=
=
WAIT_OBJECT_0
)
{
pushstring
(
stacktop
gCheckAttributesPassed
?
L
"
1
"
:
L
"
0
"
2
)
;
pushstring
(
stacktop
gCheckTrustPassed
?
L
"
1
"
:
L
"
0
"
2
)
;
pushstring
(
stacktop
L
"
1
"
2
)
;
}
else
{
pushstring
(
stacktop
L
"
0
"
2
)
;
}
}
BOOL
WINAPI
DllMain
(
HINSTANCE
hInst
DWORD
fdwReason
LPVOID
)
{
if
(
fdwReason
=
=
DLL_PROCESS_ATTACH
)
{
gHInst
=
hInst
;
gCheckEvent
=
CreateEvent
(
NULL
FALSE
FALSE
NULL
)
;
}
return
TRUE
;
}
int
popstring
(
stack_t
*
*
stacktop
LPTSTR
str
int
len
)
{
stack_t
*
th
;
if
(
!
stacktop
|
|
!
*
stacktop
)
{
return
1
;
}
th
=
(
*
stacktop
)
;
lstrcpyn
(
str
th
-
>
text
len
)
;
*
stacktop
=
th
-
>
next
;
GlobalFree
(
(
HGLOBAL
)
th
)
;
return
0
;
}
void
pushstring
(
stack_t
*
*
stacktop
LPCTSTR
str
int
len
)
{
stack_t
*
th
;
if
(
!
stacktop
)
{
return
;
}
th
=
(
stack_t
*
)
GlobalAlloc
(
GPTR
sizeof
(
stack_t
)
+
len
)
;
lstrcpyn
(
th
-
>
text
str
len
)
;
th
-
>
next
=
*
stacktop
;
*
stacktop
=
th
;
}
