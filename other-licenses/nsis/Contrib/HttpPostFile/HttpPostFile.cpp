#
include
<
Windows
.
h
>
#
include
<
Wininet
.
h
>
#
define
AGENT_NAME
L
"
HttpPostFile
plugin
"
PBYTE
LoadFileData
(
LPWSTR
fileName
DWORD
&
cbData
)
;
bool
HttpPost
(
LPURL_COMPONENTS
pUrl
LPWSTR
contentTypeHeader
PBYTE
data
DWORD
cbData
)
;
typedef
struct
_stack_t
{
struct
_stack_t
*
next
;
WCHAR
text
[
1
]
;
}
stack_t
;
static
stack_t
*
popstack
(
stack_t
*
*
stacktop
)
{
if
(
!
stacktop
|
|
!
*
stacktop
)
return
nullptr
;
stack_t
*
element
=
*
stacktop
;
*
stacktop
=
element
-
>
next
;
element
-
>
next
=
nullptr
;
return
element
;
}
static
void
pushstring
(
LPCWSTR
str
stack_t
*
*
stacktop
unsigned
int
stringsize
)
{
stack_t
*
element
;
if
(
!
stacktop
)
return
;
element
=
(
stack_t
*
)
GlobalAlloc
(
GPTR
(
sizeof
(
stack_t
)
+
stringsize
*
sizeof
(
*
str
)
)
)
;
lstrcpynW
(
element
-
>
text
str
stringsize
)
;
element
-
>
next
=
*
stacktop
;
*
stacktop
=
element
;
}
BOOL
APIENTRY
DllMain
(
HINSTANCE
instance
DWORD
reason
LPVOID
)
{
return
TRUE
;
}
extern
"
C
"
{
void
__declspec
(
dllexport
)
Post
(
HWND
hwndParent
int
string_size
char
*
stack_t
*
*
stacktop
void
*
)
{
static
const
URL_COMPONENTS
kZeroComponents
=
{
0
}
;
const
WCHAR
*
errorMsg
=
L
"
error
"
;
DWORD
cbData
=
INVALID_FILE_SIZE
;
PBYTE
data
=
nullptr
;
URL_COMPONENTS
components
=
kZeroComponents
;
stack_t
*
postFileName
=
popstack
(
stacktop
)
;
stack_t
*
contentTypeHeader
=
popstack
(
stacktop
)
;
stack_t
*
url
=
popstack
(
stacktop
)
;
if
(
!
postFileName
|
|
!
contentTypeHeader
|
|
!
url
)
{
errorMsg
=
L
"
error
getting
arguments
"
;
goto
finish
;
}
data
=
LoadFileData
(
postFileName
-
>
text
cbData
)
;
if
(
!
data
|
|
cbData
=
=
INVALID_FILE_SIZE
)
{
errorMsg
=
L
"
error
reading
file
"
;
goto
finish
;
}
{
int
urlBufLen
=
lstrlenW
(
url
-
>
text
)
+
1
;
components
.
dwStructSize
=
sizeof
(
components
)
;
components
.
dwHostNameLength
=
urlBufLen
;
components
.
dwUrlPathLength
=
urlBufLen
;
components
.
lpszHostName
=
(
LPWSTR
)
GlobalAlloc
(
GPTR
urlBufLen
*
sizeof
(
WCHAR
)
)
;
components
.
lpszUrlPath
=
(
LPWSTR
)
GlobalAlloc
(
GPTR
urlBufLen
*
sizeof
(
WCHAR
)
)
;
}
errorMsg
=
L
"
error
parsing
URL
"
;
if
(
components
.
lpszHostName
&
&
components
.
lpszUrlPath
&
&
InternetCrackUrl
(
url
-
>
text
0
0
&
components
)
&
&
(
components
.
nScheme
=
=
INTERNET_SCHEME_HTTP
|
|
components
.
nScheme
=
=
INTERNET_SCHEME_HTTPS
)
)
{
errorMsg
=
L
"
error
sending
HTTP
request
"
;
if
(
HttpPost
(
&
components
contentTypeHeader
-
>
text
data
cbData
)
)
{
errorMsg
=
nullptr
;
}
}
finish
:
if
(
components
.
lpszUrlPath
)
{
GlobalFree
(
components
.
lpszUrlPath
)
;
}
if
(
components
.
lpszHostName
)
{
GlobalFree
(
components
.
lpszHostName
)
;
}
if
(
data
)
{
GlobalFree
(
data
)
;
}
if
(
url
)
{
GlobalFree
(
url
)
;
}
if
(
contentTypeHeader
)
{
GlobalFree
(
contentTypeHeader
)
;
}
if
(
postFileName
)
{
GlobalFree
(
postFileName
)
;
}
if
(
errorMsg
)
{
pushstring
(
errorMsg
stacktop
string_size
)
;
}
else
{
pushstring
(
L
"
success
"
stacktop
string_size
)
;
}
}
}
PBYTE
LoadFileData
(
LPWSTR
fileName
DWORD
&
cbData
)
{
bool
success
=
false
;
HANDLE
hPostFile
=
INVALID_HANDLE_VALUE
;
PBYTE
data
=
nullptr
;
DWORD
bytesRead
;
DWORD
bytesReadTotal
;
hPostFile
=
CreateFile
(
fileName
GENERIC_READ
FILE_SHARE_READ
nullptr
OPEN_EXISTING
FILE_ATTRIBUTE_NORMAL
nullptr
)
;
if
(
hPostFile
=
=
INVALID_HANDLE_VALUE
)
{
goto
finish
;
}
cbData
=
GetFileSize
(
hPostFile
NULL
)
;
if
(
cbData
=
=
INVALID_FILE_SIZE
)
{
goto
finish
;
}
data
=
(
PBYTE
)
GlobalAlloc
(
GPTR
cbData
)
;
if
(
!
data
)
{
goto
finish
;
}
bytesReadTotal
=
0
;
do
{
if
(
!
ReadFile
(
hPostFile
data
+
bytesReadTotal
cbData
-
bytesReadTotal
&
bytesRead
nullptr
)
)
{
goto
finish
;
}
bytesReadTotal
+
=
bytesRead
;
}
while
(
bytesReadTotal
<
cbData
&
&
bytesRead
>
0
)
;
if
(
bytesReadTotal
=
=
cbData
)
{
success
=
true
;
}
finish
:
if
(
!
success
)
{
if
(
data
)
{
GlobalFree
(
data
)
;
data
=
nullptr
;
}
cbData
=
INVALID_FILE_SIZE
;
}
if
(
hPostFile
!
=
INVALID_HANDLE_VALUE
)
{
CloseHandle
(
hPostFile
)
;
hPostFile
=
INVALID_HANDLE_VALUE
;
}
return
data
;
}
bool
HttpPost
(
LPURL_COMPONENTS
pUrl
LPWSTR
contentTypeHeader
PBYTE
data
DWORD
cbData
)
{
bool
success
=
false
;
HINTERNET
hInternet
=
nullptr
;
HINTERNET
hConnect
=
nullptr
;
HINTERNET
hRequest
=
nullptr
;
hInternet
=
InternetOpen
(
AGENT_NAME
INTERNET_OPEN_TYPE_PRECONFIG
nullptr
nullptr
0
)
;
if
(
!
hInternet
)
{
goto
finish
;
}
hConnect
=
InternetConnect
(
hInternet
pUrl
-
>
lpszHostName
pUrl
-
>
nPort
nullptr
nullptr
INTERNET_SERVICE_HTTP
0
0
)
;
if
(
!
hConnect
)
{
goto
finish
;
}
{
DWORD
httpFlags
=
INTERNET_FLAG_NO_CACHE_WRITE
|
INTERNET_FLAG_NO_COOKIES
|
INTERNET_FLAG_NO_UI
|
INTERNET_FLAG_RELOAD
;
if
(
pUrl
-
>
nScheme
=
=
INTERNET_SCHEME_HTTPS
)
{
httpFlags
|
=
INTERNET_FLAG_SECURE
;
}
hRequest
=
HttpOpenRequest
(
hConnect
L
"
POST
"
pUrl
-
>
lpszUrlPath
nullptr
nullptr
nullptr
httpFlags
0
)
;
if
(
!
hRequest
)
{
goto
finish
;
}
}
if
(
contentTypeHeader
)
{
if
(
!
HttpAddRequestHeaders
(
hRequest
contentTypeHeader
-
1L
HTTP_ADDREQ_FLAG_ADD
)
)
{
goto
finish
;
}
}
if
(
!
HttpSendRequestW
(
hRequest
nullptr
0
data
cbData
)
)
{
goto
finish
;
}
BYTE
readBuffer
[
1024
]
;
DWORD
bytesRead
;
do
{
if
(
!
InternetReadFile
(
hRequest
readBuffer
sizeof
(
readBuffer
)
&
bytesRead
)
)
{
goto
finish
;
}
}
while
(
bytesRead
>
0
)
;
success
=
true
;
finish
:
if
(
hRequest
)
{
InternetCloseHandle
(
hRequest
)
;
}
if
(
hConnect
)
{
InternetCloseHandle
(
hConnect
)
;
}
if
(
hInternet
)
{
InternetCloseHandle
(
hInternet
)
;
}
return
success
;
}
