#
include
<
windows
.
h
>
#
include
<
bits
.
h
>
#
include
<
utility
>
#
if
!
(
defined
(
UNICODE
)
&
&
defined
(
_UNICODE
)
)
#
error
"
Unicode
required
"
#
endif
static
HINSTANCE
gHInst
;
template
<
typename
ExitFunction
>
class
ScopeExit
{
ExitFunction
mExitFunction
;
bool
mExecuteOnDestruction
;
public
:
explicit
ScopeExit
(
ExitFunction
&
&
cleanup
)
:
mExitFunction
(
cleanup
)
mExecuteOnDestruction
(
true
)
{
}
ScopeExit
(
ScopeExit
&
&
rhs
)
:
mExitFunction
(
std
:
:
move
(
rhs
.
mExitFunction
)
)
mExecuteOnDestruction
(
rhs
.
mExecuteOnDestruction
)
{
rhs
.
release
(
)
;
}
~
ScopeExit
(
)
{
if
(
mExecuteOnDestruction
)
{
mExitFunction
(
)
;
}
}
void
release
(
)
{
mExecuteOnDestruction
=
false
;
}
private
:
explicit
ScopeExit
(
const
ScopeExit
&
)
=
delete
;
ScopeExit
&
operator
=
(
const
ScopeExit
&
)
=
delete
;
ScopeExit
&
operator
=
(
ScopeExit
&
&
)
=
delete
;
}
;
template
<
typename
ExitFunction
>
ScopeExit
<
ExitFunction
>
MakeScopeExit
(
ExitFunction
&
&
exitFunction
)
{
return
ScopeExit
<
ExitFunction
>
(
std
:
:
move
(
exitFunction
)
)
;
}
typedef
struct
_stack_t
{
struct
_stack_t
*
next
;
WCHAR
text
[
1
]
;
}
stack_t
;
static
unsigned
int
g_stringsize
;
static
stack_t
*
*
g_stacktop
;
static
int
popstringn
(
LPWSTR
str
int
maxlen
)
{
stack_t
*
th
;
if
(
!
g_stacktop
|
|
!
*
g_stacktop
)
return
1
;
th
=
(
*
g_stacktop
)
;
if
(
str
)
lstrcpynW
(
str
th
-
>
text
maxlen
?
maxlen
:
g_stringsize
)
;
*
g_stacktop
=
th
-
>
next
;
GlobalFree
(
(
HGLOBAL
)
th
)
;
return
0
;
}
static
void
pushstring
(
LPCWSTR
str
)
{
stack_t
*
th
;
if
(
!
g_stacktop
)
return
;
th
=
(
stack_t
*
)
GlobalAlloc
(
GPTR
(
sizeof
(
stack_t
)
+
(
g_stringsize
)
*
sizeof
(
*
str
)
)
)
;
lstrcpynW
(
th
-
>
text
str
g_stringsize
)
;
th
-
>
next
=
*
g_stacktop
;
*
g_stacktop
=
th
;
}
enum
NSPIM
{
NSPIM_UNLOAD
NSPIM_GUIUNLOAD
}
;
typedef
UINT_PTR
(
*
NSISPLUGINCALLBACK
)
(
enum
NSPIM
)
;
#
define
NSISCALL
__stdcall
typedef
struct
{
LPVOID
exec_flags
;
int
(
NSISCALL
*
ExecuteCodeSegment
)
(
int
HWND
)
;
void
(
NSISCALL
*
validate_filename
)
(
LPWSTR
)
;
int
(
NSISCALL
*
RegisterPluginCallback
)
(
HMODULE
NSISPLUGINCALLBACK
)
;
}
extra_parameters
;
UINT_PTR
__cdecl
NSISPluginCallback
(
NSPIM
msg
)
;
static
struct
{
HANDLE
thread
;
bool
shutdown_requested
;
CRITICAL_SECTION
cs
;
CONDITION_VARIABLE
cv
;
}
gStartBitsThread
=
{
nullptr
false
0
0
}
;
DWORD
WINAPI
StartBitsThreadProc
(
LPVOID
)
{
EnterCriticalSection
(
&
gStartBitsThread
.
cs
)
;
auto
leaveCS
=
MakeScopeExit
(
[
]
{
LeaveCriticalSection
(
&
gStartBitsThread
.
cs
)
;
}
)
;
if
(
FAILED
(
CoInitializeEx
(
nullptr
COINIT_MULTITHREADED
)
)
)
{
return
0
;
}
auto
coUninit
=
MakeScopeExit
(
[
]
{
CoUninitialize
(
)
;
}
)
;
IBackgroundCopyManager
*
bcm
=
nullptr
;
if
(
FAILED
(
CoCreateInstance
(
__uuidof
(
BackgroundCopyManager
)
nullptr
CLSCTX_LOCAL_SERVER
__uuidof
(
IBackgroundCopyManager
)
(
LPVOID
*
)
&
bcm
)
)
|
|
!
bcm
)
{
return
0
;
}
do
{
SleepConditionVariableCS
(
&
gStartBitsThread
.
cv
&
gStartBitsThread
.
cs
INFINITE
)
;
}
while
(
!
gStartBitsThread
.
shutdown_requested
)
;
bcm
-
>
Release
(
)
;
return
1
;
}
bool
StartBitsServiceBackgroundThreadImpl
(
extra_parameters
*
extra_params
)
{
EnterCriticalSection
(
&
gStartBitsThread
.
cs
)
;
auto
leaveCS
=
MakeScopeExit
(
[
]
{
LeaveCriticalSection
(
&
gStartBitsThread
.
cs
)
;
}
)
;
if
(
gStartBitsThread
.
thread
)
{
return
true
;
}
extra_params
-
>
RegisterPluginCallback
(
gHInst
NSISPluginCallback
)
;
gStartBitsThread
.
shutdown_requested
=
false
;
gStartBitsThread
.
thread
=
CreateThread
(
nullptr
0
StartBitsThreadProc
nullptr
0
0
)
;
if
(
!
gStartBitsThread
.
thread
)
{
return
false
;
}
return
true
;
}
void
ShutdownStartBitsThread
(
)
{
EnterCriticalSection
(
&
gStartBitsThread
.
cs
)
;
if
(
gStartBitsThread
.
thread
)
{
gStartBitsThread
.
shutdown_requested
=
true
;
WakeAllConditionVariable
(
&
gStartBitsThread
.
cv
)
;
LeaveCriticalSection
(
&
gStartBitsThread
.
cs
)
;
if
(
WaitForSingleObject
(
gStartBitsThread
.
thread
1000
)
=
=
WAIT_OBJECT_0
)
{
EnterCriticalSection
(
&
gStartBitsThread
.
cs
)
;
gStartBitsThread
.
thread
=
nullptr
;
LeaveCriticalSection
(
&
gStartBitsThread
.
cs
)
;
}
else
{
}
}
else
{
LeaveCriticalSection
(
&
gStartBitsThread
.
cs
)
;
}
}
#
define
MAX_JOB_NAME
256
bool
CancelBitsJobsByNameImpl
(
LPWSTR
matchJobName
)
{
if
(
FAILED
(
CoInitialize
(
nullptr
)
)
)
{
return
false
;
}
auto
coUninit
=
MakeScopeExit
(
[
]
{
CoUninitialize
(
)
;
}
)
;
IBackgroundCopyManager
*
bcm
=
nullptr
;
if
(
FAILED
(
CoCreateInstance
(
__uuidof
(
BackgroundCopyManager
)
nullptr
CLSCTX_LOCAL_SERVER
__uuidof
(
IBackgroundCopyManager
)
(
LPVOID
*
)
&
bcm
)
)
|
|
!
bcm
)
{
return
false
;
}
auto
bcmRelease
=
MakeScopeExit
(
[
bcm
]
{
bcm
-
>
Release
(
)
;
}
)
;
IEnumBackgroundCopyJobs
*
enumerator
=
nullptr
;
if
(
FAILED
(
bcm
-
>
EnumJobs
(
BG_JOB_ENUM_ALL_USERS
&
enumerator
)
)
)
{
enumerator
=
nullptr
;
if
(
FAILED
(
bcm
-
>
EnumJobs
(
0
&
enumerator
)
)
)
{
return
false
;
}
}
if
(
!
enumerator
)
{
return
false
;
}
auto
enumeratorRelease
=
MakeScopeExit
(
[
enumerator
]
{
enumerator
-
>
Release
(
)
;
}
)
;
bool
success
=
true
;
IBackgroundCopyJob
*
job
=
nullptr
;
HRESULT
nextResult
;
while
(
(
nextResult
=
enumerator
-
>
Next
(
1
&
job
nullptr
)
SUCCEEDED
(
nextResult
)
)
)
{
if
(
nextResult
=
=
S_FALSE
)
{
break
;
}
if
(
!
job
)
{
success
=
false
;
break
;
}
LPWSTR
curJobName
=
nullptr
;
if
(
SUCCEEDED
(
job
-
>
GetDisplayName
(
&
curJobName
)
)
&
&
curJobName
)
{
if
(
lstrcmpW
(
curJobName
matchJobName
)
=
=
0
)
{
if
(
!
SUCCEEDED
(
job
-
>
Cancel
(
)
)
)
{
success
=
false
;
}
}
CoTaskMemFree
(
(
LPVOID
)
curJobName
)
;
curJobName
=
nullptr
;
}
else
{
success
=
false
;
}
job
-
>
Release
(
)
;
job
=
nullptr
;
}
if
(
!
SUCCEEDED
(
nextResult
)
)
{
success
=
false
;
}
return
success
;
}
extern
"
C
"
{
void
__declspec
(
dllexport
)
CancelBitsJobsByName
(
HWND
hwndParent
int
string_size
char
*
variables
stack_t
*
*
stacktop
extra_parameters
*
)
{
g_stacktop
=
stacktop
;
g_stringsize
=
string_size
;
WCHAR
matchJobName
[
MAX_JOB_NAME
+
1
]
;
matchJobName
[
0
]
=
L
'
\
0
'
;
if
(
!
popstringn
(
matchJobName
sizeof
(
matchJobName
)
/
sizeof
(
WCHAR
)
)
)
{
if
(
CancelBitsJobsByNameImpl
(
matchJobName
)
)
{
pushstring
(
L
"
ok
"
)
;
return
;
}
}
pushstring
(
L
"
error
"
)
;
}
void
__declspec
(
dllexport
)
StartBitsServiceBackground
(
HWND
int
char
*
stack_t
*
*
extra_parameters
*
extra_params
)
{
StartBitsServiceBackgroundThreadImpl
(
extra_params
)
;
}
}
UINT_PTR
__cdecl
NSISPluginCallback
(
NSPIM
msg
)
{
if
(
msg
=
=
NSPIM_UNLOAD
)
{
ShutdownStartBitsThread
(
)
;
}
return
0
;
}
BOOL
APIENTRY
DllMain
(
HINSTANCE
instance
DWORD
reason
LPVOID
)
{
if
(
reason
=
=
DLL_PROCESS_ATTACH
)
{
gHInst
=
instance
;
InitializeConditionVariable
(
&
gStartBitsThread
.
cv
)
;
InitializeCriticalSection
(
&
gStartBitsThread
.
cs
)
;
}
return
TRUE
;
}
